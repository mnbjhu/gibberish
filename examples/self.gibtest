token KEYWORD = "keyword[^_a-zA-Z]";
token PARSER = "parser[^_a-zA-Z]";
token TOKEN = "token[^_a-zA-Z]";
token HIGHTLIGHT = "highlight[^_a-zA-Z]";
token FOLD = "fold[^_a-zA-Z]";

token whitespace = "[ \t\n\f]+"; 
token int = "[0-9]+";
token colon = ":";
token comma = ",";
token bar = "\|";
token dot = "\.";
token l_bracket = "\[";
token r_bracket = "\]";
token l_paren = "\(";
token r_paren = "\)";
token l_brace = "\{";
token r_brace = "\}";
token plus = "\+";
token eq = "=";
token ident = "[_a-zA-Z][_a-zA-Z0-9]*";
token semi = ";";
token string = "\"(?:\\\\.|[^\"\\\\])*\"";


parser _expr;
parser named = ident;
parser _atom = _expr.delim_by(l_paren, r_paren) | named;
parser call_name = ident;
parser call = dot + call_name + _expr.sep_by(comma).delim_by(l_paren, r_paren);
parser member_call = _atom fold call;
parser seq = member_call fold plus + member_call;
parser choice = seq fold bar + seq;
parser _expr = choice;

parser kw_def = KEYWORD + ident;
parser token_def = TOKEN + ident + eq + string;

parser fold_stmt = _expr fold FOLD + _expr;
parser parser_def = PARSER + ident + (eq + fold_stmt).or_not();
parser _stmt = kw_def | token_def | parser_def;
parser root = _stmt.sep_by(semi).skip(whitespace)
