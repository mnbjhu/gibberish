keyword function;
keyword export;
keyword data;
keyword type;
keyword align;

keyword add;
keyword sub;
keyword mul;

keyword and;
keyword or;

keyword ceql;
keyword ceqw;
keyword ceqb;

keyword culel;
keyword cugel;
keyword cultl;
keyword cugtl;
keyword culew;
keyword cugew;
keyword cultw;
keyword cugtw;
keyword culeb;
keyword cugeb;
keyword cultb;
keyword cugtb;
keyword cslel;
keyword csgel;
keyword csltl;
keyword csgtl;
keyword cslew;
keyword csgew;
keyword csltw;
keyword csgtw;
keyword csleb;
keyword csgeb;
keyword csltb;
keyword csgtb;

keyword copy;

keyword storew;
keyword storel;
keyword storeb;
keyword storeub;

keyword loadl;
keyword loadw;
keyword loadb;
keyword loadub;

keyword call;

keyword jmp;
keyword jnz;
keyword b;
keyword w;
keyword l;
keyword ret;

keyword alloc4;
keyword alloc8;
keyword alloc16;
keyword blit;

token string = "\"[^\"]*\"";
token comment = "#[^\n]+";
token type_name = ":[_a-zA-Z][_a-zA-Z0-9]*";
token global = "\$[_a-zA-Z][_a-zA-Z0-9]*";
token label = "@[_a-zA-Z][_a-zA-Z0-9]*";
token temp = "%[_a-zA-Z][_a-zA-Z0-9]*";
token ident = "[_a-zA-Z][_a-zA-Z0-9]*";
token newline = "[ \t]*\n\s*";
token ws = "[ \t]+";

token str = "\"[^\"]*\"";
token int = "[0-9]+";
token colon = ":";
token eqw = "=w";
token eqb = "=b";
token eql = "=l";
token eq = "=";
token comma = ",";
token l_bracket = "\[";
token r_bracket = "\]";
token l_brace = "\{";
token r_brace = "\}";
token l_paren = "\(";
token r_paren = "\)";

parser _name = temp | global | label | int;
parser ty = (b | w | l | type_name);

parser call_arg = ty + _name;
parser call_args = call_arg.sep_by(comma).delim_by(l_paren, r_paren);


parser _cmp_kw = culel | cugel | cultl | cugtl | culew | cugew | cultw | cugtw | culeb | cugeb | cultb | cugtb | cslel | csgel | csltl | csgtl | cslew | csgew | csltw | csgtw | csleb | csgeb | csltb | csgtb | 
  ceql | ceqw | ceqb;



parser ret_instr = ret + _name;
parser cmp_instr = _cmp_kw + _name + comma + _name;
parser add_instr = add + _name + comma + _name;
parser and_instr = and + _name + comma + _name;
parser or_instr = or + _name + comma + _name;
parser sub_instr = sub + _name + comma + _name;
parser mul_instr = mul + _name + comma + _name;
parser jnz_instr = jnz + temp + comma + label + comma + label;
parser jmp_instr = jmp + label;
parser copy_instr = copy + _name;
parser store_instr = (storew | storel | storeub | storeb) + _name + comma + _name;
parser load_instr = (loadl | loadw | loadb | loadub) + _name;
parser call_instr = call + global + call_args;

parser alloc_instr = (alloc4 | alloc8 | alloc16) + _name;
parser blit_instr = blit + _name + comma + _name + comma + _name;

parser _unassignable_instr = store_instr | jmp_instr | jnz_instr | ret_instr | blit_instr;
parser _assignable_instr = add_instr | mul_instr  |sub_instr | cmp_instr | copy_instr | load_instr | or_instr | and_instr | call_instr | alloc_instr;


parser assignment = temp + (eqw | eql | eqb | (eq + type_name)) + _assignable_instr;
parser _stmt = (assignment | _assignable_instr | _unassignable_instr);

parser func_arg = ty + temp;
parser func_args = func_arg.sep_by(comma).delim_by(l_paren, r_paren);

parser block = label + _stmt.repeated();
parser func_body = l_brace + block.repeated() + r_brace;

parser function_def = export.or_not() + function + ty + global + func_args + func_body;

parser data_part = ty + (int | string);
parser data_def = export.or_not() + data + global + eq + data_part.sep_by(comma).delim_by(l_brace, r_brace);

parser type_part = ty + int.or_not();
parser alignment = align + int;
parser type_def = type + type_name + eq + alignment.or_not() + type_part.sep_by(comma).delim_by(l_brace, r_brace);
parser _decl = data_def | function_def | type_def;

parser _root = _decl.repeated().skip(comment).skip(newline).skip(ws)
