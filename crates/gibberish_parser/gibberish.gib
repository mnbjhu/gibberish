token KEYWORD = "(keyword)[^_a-zA-Z]";
token PARSER = "(parser)[^_a-zA-Z]";
token TOKEN = "(token)[^_a-zA-Z]";
token HIGHTLIGHT = "(highlight)[^_a-zA-Z]";
token FOLD = "(fold)[^_a-zA-Z]";

token whitespace = "[ \t\n]+"; 
token int = "[0-9]+";
token colon = ":";
token comma = ",";
token bar = "\|";
token dot = "\.";
token l_bracket = "\[";
token r_bracket = "\]";
token l_paren = "\(";
token r_paren = "\)";
token l_brace = "\{";
token r_brace = "\}";
token plus = "\+";
token eq = "=";
token ident = "[_a-zA-Z][_a-zA-Z0-9]*";
token semi = ";";
token string = "\"(?:\\\\.|[^\"\\\\])*\"";
token at = "@";


parser named = ident;
parser _atom = (_expr.delim_by(l_paren, r_paren) | named).labelled(expression);
parser call_name = ident;
parser args = _expr.sep_by(comma).or_not().delim_by(l_paren, r_paren);
parser call = dot + call_name + args;
parser member_call = _atom fold call.repeated();
parser seq = member_call.labelled(expression) fold (plus + member_call.labelled(expression)).repeated();
parser choice = seq.labelled(expression) fold (bar + seq.labelled(expression)).repeated();
parser _expr = choice.labelled(expression);

parser kw_def = KEYWORD + ident.labelled(token_name);
parser token_def = TOKEN + ident.labelled(token_name) + eq + string.labelled(regex);

parser fold_stmt = _expr fold FOLD + _expr;
parser parser_def = PARSER + ident.labelled(parser_name) + eq + fold_stmt;

parser child_query = _query.sep_by(comma).or_not().delim_by(l_paren, r_paren);
parser group_query = named + (colon + child_query).or_not();
parser label = at + string;
parser labelled_query = group_query fold label;
parser _query = labelled_query;

parser highlight_def = HIGHTLIGHT + _query;

parser _stmt = kw_def | token_def | parser_def | highlight_def;
parser root = _stmt
  .labelled(declaration)
  .sep_by(semi)
  .skip(whitespace)
