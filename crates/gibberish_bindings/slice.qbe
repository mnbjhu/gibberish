type :str_slice = { l 2 }
type :vec = { l 3 }
type :token = { l 3 }

type :node = { w 2, l 3 }

data $match_just = { b "Matched just %d\n", b 0 }
data $eof_just = { b "Eof just %d\n", b 0 }
data $skipped_just = { b "Skipped just %d\n", b 0 }
data $break_just = { b "Break just %d\n", b 0 }
data $err_just = { b "Err just %d\n", b 0 }


# <stack: 3> <tokens: 3> <offset: 1> <delim_stack: 3> <skip: 3>
type :state = { l 3, l 3, l, l 3, l 3 }

export function :vec $test_vec_contains() {
@start
    %vec =:vec call $new_vec(l 8)
    call $push_long(l %vec, l 0)
    call $push_long(l %vec, l 1)
    call $push_long(l %vec, l 2)
    #%res =l call $contains_long(l %vec, l 1)
    ret %vec
}

function w $is_eof(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %tokens_len =l loadl %tokens_len_ptr

    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %res =w ceql %current, %tokens_len
    ret %res
}

data $skipping_token = { b "Skipping token %u\n", b 0 }

export function w $skip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @already, @push
@already
    ret 0
@push
    call $push_long(l %skip_ptr, l %token_kind)
    ret 1
}

export function w $unskip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @already, @remove
@already
    ret 0
@remove
    %index =l sub %already, 1
    call $remove_long(l %skip_ptr, l %index)
    ret 1
}

function w $remove_long(l %vec, l %index) {
@start
    %len_ptr =l add %vec, 8
    %len =l loadl %len_ptr
    %end =l mul %len, 8
    %offset =l mul %index, 8
    %after =l add %index, 8
    %cpy_size =l sub %end, %after
    call $memcpy(l %offset, l %after, l %cpy_size)
    %len =l sub %len, 1
    storel %len, %len_ptr
    ret 1
}

data $checking_skipped = { b "Checking %u == %u\n" ,b 0}
data $found_skipped = { b "Found %d\n" ,b 0}
data $info_msg = {b "Checking contains long for arr %u, len: %u\n"}

function l $contains_long(l %vec, l %value) {
@start
    %ptr =l loadl %vec
    %len_ptr =l add %vec, 8
    %len =l loadl %len_ptr
    %index =l copy 0
    %item_ptr =l loadl %vec
    jnz %len, @loop, @false
@loop
    %item =l loadl %item_ptr
    %found =l ceql %item, %value
    jnz %found, @true, @iter
@iter
    %index =l add %index, 1
    %item_ptr =l add %item_ptr, 8
    %is_end =l ceql %index, %len
    jnz %is_end, @false, @loop
@false
    ret 0
@true
    %res =l add %index, 1
    ret %res
}

function l $push_delim(l %state_ptr, l %delim) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $push_long(l %delim_stack_ptr, l %delim)
    %delim_len_ptr =l add %delim_stack_ptr, 8
    %delim_len =l loadl %delim_len_ptr
    %res =l add 2, %delim_len
    ret %res
}

function w $pop_delim(l %state_ptr) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $pop(l %delim_stack_ptr, l 8)
    ret 1
}

export function w $bumpN(l %state_ptr, l %n) {
@start
    jmp @loop
@loop
    jnz %n, @iter, @ret
@iter
    %n =l sub %n, 1
    call $bump(l %state_ptr)
    jmp @loop
@ret
    ret 1
}

export function w $enter_group(l %state_ptr, w %group_kind) {
@start
    %stack_ptr =l add %state_ptr, 24
    %new =:node call $new_group_node(w %group_kind)
    call $push(l %stack_ptr, l 32, l %new)
    ret 1
}

function l $current_kind(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %token_ptr =l call $get(l %state_ptr, l 24, l %current)
    %token =l loadl %token_ptr
    ret %token
}

export function l $kind_at_offset(l %state_ptr, l %offset) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %at_offset =l add %current, %offset
    %token_ptr =l call $get(l %state_ptr, l 24, l %at_offset)
    %token =l loadl %token_ptr
    ret %token
}

data $skipped_msg = { b "SKIPPED\n", b 0}
function l $after_skipped(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %current_ptr =l add %state_ptr, 48

    %current =l loadl %current_ptr
    %len =l loadl %tokens_len_ptr

    %offset =l copy 0
    %skip_ptr =l add %state_ptr, 80
@check_eof
    %index =l add %offset, %current
    %is_eof =l ceql %len, %index
    jnz %is_eof, @ret, @loop
@loop
    %kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %is_skipped =l call $contains_long(l %skip_ptr, l %kind)
    jnz %is_skipped, @iter, @ret
@iter
    %offset =l add %offset, 1
    jmp @check_eof
@ret
    ret %offset
}

export function w $exit_group(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24

    %removed =l call $pop(l %stack_ptr, l 32)
    %last =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %last, 8

    call $push(l %children_ptr, l 32, l %removed)
    ret 1
}

export function w $bump(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)
    %start_ptr =l add %tok_ptr, 8
    %end_ptr =l add %tok_ptr, 16


    %current =l add %current, 1
    storel %current, %current_ptr

    %token =l loadl %tok_ptr
    %start =l loadl %start_ptr
    %end =l loadl %end_ptr

    %new =:node call $new_token_node(l %token, l %start, l %end)

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8

    call $push(l %children_ptr, l 32, l %new)

    ret 1
}

export function w $missing(l %state_ptr, l %expected) {
@check_zero_expected
    %ptr =l loadl %expected
    jnz %ptr, @start, @ret
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8
    %missing =:node call $new_missing_node(l %expected)
    call $push(l %children_ptr, l 32, l %missing)
    ret 1
@ret
    ret 1
}

export function w $bump_err(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)

    %current =l add %current, 1
    storel %current, %current_ptr

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %children_ptr =l add %current_group, 8
    %last_child =l call $last(l %children_ptr, l 32)

    %last_child_kind =l loadl %last_child
    %last_is_err =l ceql %last_child_kind, 2
    jnz %last_is_err, @extend_err, @new_error
@extend_err
    %tokens =l add %last_child, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    ret 1
@new_error
    %new_node =:node call $new_error_node()
    %tokens =l add %new_node, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    call $push(l %children_ptr, l 32, l %new_node)
    ret 1
}

export function l $default_state_ptr(l %ptr, l %len) {
@start
    %ptr =:state call $default_state(l %ptr, l %len)
    %res =l call $malloc(l 104)
    call $memcpy(l %res, l %ptr, l 104)
    ret %res
}

export function :state $get_state(l %ptr) {
@start
    %state =l alloc8 104
    blit %ptr, %state, 104
    ret %state
}

export function l $last(l %vec_ptr, l %size) {
@start
    %ptr =l loadl %vec_ptr

    %len_ptr =l add %vec_ptr, 8
    %len =l loadl %len_ptr

    %index =l sub %len, 1

    %offset =l mul %index, %size
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

export function :state $default_state(l %ptr, l %len) {
@start
    %tokens =:vec call $lex(l %ptr, l %len)
    %res =:state call $new_state(:vec %tokens)
    ret %res
}

function :state $new_state(:vec %tokens) {
@start
    %res =l alloc8 104
    %stack_ptr =l add %res, 24
    %offset_ptr =l add %res, 48
    %delim_stack_ptr =l add %res, 56
    %skip_ptr =l add %res, 80

    %root =w loadw $root_group_id
    %group =:node call $new_group_node(w %root)

    %stack =:vec call $new_vec(l 32)
    call $push(l %stack, l 32, l %group)

    %delim_stack =:vec call $new_vec(l 8)
    %skip =:vec call $new_vec(l 8)

    blit %tokens, %res, 24
    blit %stack, %stack_ptr, 24
    blit %delim_stack, %delim_stack_ptr, 24
    blit %skip, %skip_ptr, 24
    storel 0, %offset_ptr

    ret %res
}

data $debug_group = { b "Group { kind: %d, group_kind: %d, ptr: %d, len: %d, cap: %d, }", b 0 }

function w $print_group(:node %group) {
@start
    %group_kind_ptr =l add %group, 4
    %ptr_ptr =l add %group, 8
    %len_ptr =l add %group, 16
    %cap_ptr =l add %group, 24

    %kind =l loadw %group
    %group_kind =l loadw %group_kind_ptr
    %ptr =l loadl %ptr_ptr
    %len =l loadl %len_ptr
    %cap =l loadl %cap_ptr
    ret 1
}

export function l $get(l %vec_ptr, l %size, l %index) {
@start
    %ptr =l loadl %vec_ptr
    %offset =l mul %size, %index
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

data $AHH = { b "AHHH", b 0 }
export function :node $new_token_node(l %kind, l %start, l %end) {
@start
    %res =l alloc8 32
    %kind_ptr =l add %res, 8
    %start_ptr =l add %res, 16
    %end_ptr =l add %res, 24
    storel 0, %res
    storel %kind, %kind_ptr
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function :node $new_missing_node(l %expected) {
@start
    %res =l alloc8 32
    %expected_ptr =l add 8, %res
    blit %expected, %expected_ptr, 24
    storew 3, %res
    ret %res
}

export function :node $new_group_node(w %kind) {
@start
    %res =l alloc8 32
    %group_kind =l add %res, 4
    %vec =:vec call $new_vec(l 32)
    %vec_ptr =l add %res, 8
    %group_kind_ptr =l add 4, %res
    blit %vec, %vec_ptr, 24
    storew 1, %res
    storew %kind, %group_kind_ptr
    ret %res
}



export function :node $new_error_node() {
@start
    %res =l alloc8 32
    %vec =:vec call $new_vec(l 24)
    %vec_ptr =l add %res, 8
    blit %vec, %vec_ptr, 24
    storel 2, %res
    ret %res
}

export function :vec $new_vec(l %item_size) {
@start
    %ptr_ptr =l alloc8 24
    %len_ptr =l add %ptr_ptr, 8
    %cap_ptr =l add %ptr_ptr, 16

    %size =l mul %item_size, 4
    %ptr =l call $malloc(l %size)

    storel %ptr, %ptr_ptr
    storel 0, %len_ptr
    storel 4, %cap_ptr
    ret %ptr_ptr
}


export function :token $new_token(l %kind, l %start, l %end) {
@start
    %res =l alloc8 24
    %start_ptr =l add %res, 8
    %end_ptr =l add %res, 16
    storel %kind, %res
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function l $pop(l %vec, l %value_size) {
@start
  %len_ptr =l add %vec, 8

  %ptr =l loadl %vec
  %len =l loadl %len_ptr

  %len =l sub %len, 1
  storel %len, %len_ptr

  %offset =l mul %len, %value_size
  %item_ptr =l add %offset, %ptr
  ret %item_ptr
}

export function w $push_long(l %vec, l %value) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %bytes =l mul %cap, 8
    %new_ptr =l call $malloc(l %bytes)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %bytes =l mul %len, 8
    call $memcpy(l %new_ptr, l %ptr, l %bytes)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
@push
    %offset =l mul %len, 8
    %item_ptr =l add %ptr, %offset
    %len =l add %len, 1
    storel %len, %len_ptr
    storel %value, %item_ptr
    ret 1
}

export function w $push(l %vec, l %value_size, l %value_ptr) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %size =l mul %cap, %value_size
    %new_ptr =l call $malloc(l %size)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %size =l mul %len, %value_size
    call $memcpy(l %new_ptr, l %ptr, l %size)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
    jmp @push
@push
    %offset =l mul %len, %value_size
    %item_ptr =l add %offset, %ptr
    %len =l add %len, 1
    storel %len, %len_ptr
    call $memcpy(l %item_ptr, l %value_ptr, l %value_size)
    ret 1
}


data $offset_ptr = { l 0 }
data $group_end = { l 0 }

function w $cmp_current(l %ptr, l %len, w %char) {
@start
    %offset =l loadl $offset_ptr
    %actual_offset =l add %ptr, %offset
    %current =w loadub %actual_offset
    %res =w ceqw %current, %char
    ret %res
}

function w $inc_offset() {
@start
    %offset =l loadl $offset_ptr
    %offset =l add %offset, 1
    storel %offset, $offset_ptr
    ret 0
}


function l $lex_1 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 107)
    call $inc_offset()
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %ptr, l %len, w 101)
    call $inc_offset()
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %ptr, l %len, w 121)
    call $inc_offset()
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %ptr, l %len, w 119)
    call $inc_offset()
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %ptr, l %len, w 111)
    call $inc_offset()
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %ptr, l %len, w 114)
    call $inc_offset()
    jnz %res, @part_6, @fail

@part_6
    %res =w call $cmp_current(l %ptr, l %len, w 100)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_3(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_4(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_5(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_2 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_3(l %ptr, l %len)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_4(l %ptr, l %len)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_5(l %ptr, l %len)
    jnz %res, @fail, @pass

@pass
    call $inc_offset()
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_0 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_1(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_2(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_KEYWORD (l %ptr, l %len) {
@start
    %res =w call $lex_0(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_7 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 112)
    call $inc_offset()
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %ptr, l %len, w 97)
    call $inc_offset()
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %ptr, l %len, w 114)
    call $inc_offset()
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %ptr, l %len, w 115)
    call $inc_offset()
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %ptr, l %len, w 101)
    call $inc_offset()
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %ptr, l %len, w 114)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_9(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_10(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_11(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_8 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_9(l %ptr, l %len)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_10(l %ptr, l %len)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_11(l %ptr, l %len)
    jnz %res, @fail, @pass

@pass
    call $inc_offset()
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_6 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_7(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_8(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_PARSER (l %ptr, l %len) {
@start
    %res =w call $lex_6(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_13 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 116)
    call $inc_offset()
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %ptr, l %len, w 111)
    call $inc_offset()
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %ptr, l %len, w 107)
    call $inc_offset()
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %ptr, l %len, w 101)
    call $inc_offset()
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %ptr, l %len, w 110)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_15(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_16(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_17(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_14 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_15(l %ptr, l %len)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_16(l %ptr, l %len)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_17(l %ptr, l %len)
    jnz %res, @fail, @pass

@pass
    call $inc_offset()
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_12 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_13(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_14(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_TOKEN (l %ptr, l %len) {
@start
    %res =w call $lex_12(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_19 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 104)
    call $inc_offset()
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %ptr, l %len, w 105)
    call $inc_offset()
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %ptr, l %len, w 103)
    call $inc_offset()
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %ptr, l %len, w 104)
    call $inc_offset()
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %ptr, l %len, w 108)
    call $inc_offset()
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %ptr, l %len, w 105)
    call $inc_offset()
    jnz %res, @part_6, @fail

@part_6
    %res =w call $cmp_current(l %ptr, l %len, w 103)
    call $inc_offset()
    jnz %res, @part_7, @fail

@part_7
    %res =w call $cmp_current(l %ptr, l %len, w 104)
    call $inc_offset()
    jnz %res, @part_8, @fail

@part_8
    %res =w call $cmp_current(l %ptr, l %len, w 116)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_21(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_22(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_23(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_20 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_21(l %ptr, l %len)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_22(l %ptr, l %len)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_23(l %ptr, l %len)
    jnz %res, @fail, @pass

@pass
    call $inc_offset()
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_18 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_19(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_20(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_HIGHTLIGHT (l %ptr, l %len) {
@start
    %res =w call $lex_18(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_25 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 102)
    call $inc_offset()
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %ptr, l %len, w 111)
    call $inc_offset()
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %ptr, l %len, w 108)
    call $inc_offset()
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %ptr, l %len, w 100)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_27(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_28(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_29(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_26 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_27(l %ptr, l %len)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_28(l %ptr, l %len)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_29(l %ptr, l %len)
    jnz %res, @fail, @pass

@pass
    call $inc_offset()
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_24 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_25(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_26(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_FOLD (l %ptr, l %len) {
@start
    %res =w call $lex_24(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function w $lex_32(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 32)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function w $lex_33(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 9)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function w $lex_34(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 10)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_31 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    storel %start, $offset_ptr
    %res =w call $lex_32(l %ptr, l %len)
    jnz %res, @pass, @part_1

@part_1
    storel %start, $offset_ptr
    %res =w call $lex_33(l %ptr, l %len)
    jnz %res, @pass, @part_2

@part_2
    storel %start, $offset_ptr
    %res =w call $lex_34(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}


function w $lex_35 (l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_31(l %ptr, l %len)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_31(l %ptr, l %len)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

function l $lex_30 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_35(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_whitespace (l %ptr, l %len) {
@start
    %res =w call $lex_30(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}


function w $lex_38(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_37 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    storel %start, $offset_ptr
    %res =w call $lex_38(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}


function w $lex_39 (l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_37(l %ptr, l %len)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_37(l %ptr, l %len)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

function l $lex_36 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_39(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_int (l %ptr, l %len) {
@start
    %res =w call $lex_36(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_41 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 58)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_40 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_41(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_colon (l %ptr, l %len) {
@start
    %res =w call $lex_40(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_43 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 44)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_42 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_43(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_comma (l %ptr, l %len) {
@start
    %res =w call $lex_42(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_45 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 124)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_44 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_45(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_bar (l %ptr, l %len) {
@start
    %res =w call $lex_44(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_47 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 46)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_46 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_47(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_dot (l %ptr, l %len) {
@start
    %res =w call $lex_46(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_49 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 91)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_48 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_49(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_l_bracket (l %ptr, l %len) {
@start
    %res =w call $lex_48(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_51 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 93)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_50 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_51(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_r_bracket (l %ptr, l %len) {
@start
    %res =w call $lex_50(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_53 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 40)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_52 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_53(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_l_paren (l %ptr, l %len) {
@start
    %res =w call $lex_52(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_55 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 41)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_54 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_55(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_r_paren (l %ptr, l %len) {
@start
    %res =w call $lex_54(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_57 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 123)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_56 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_57(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_l_brace (l %ptr, l %len) {
@start
    %res =w call $lex_56(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_59 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 125)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_58 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_59(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_r_brace (l %ptr, l %len) {
@start
    %res =w call $lex_58(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_61 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 43)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_60 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_61(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_plus (l %ptr, l %len) {
@start
    %res =w call $lex_60(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_63 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 61)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_62 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_63(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_eq (l %ptr, l %len) {
@start
    %res =w call $lex_62(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function w $lex_66(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_67(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_68(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_65 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    storel %start, $offset_ptr
    %res =w call $lex_66(l %ptr, l %len)
    jnz %res, @pass, @part_1

@part_1
    storel %start, $offset_ptr
    %res =w call $lex_67(l %ptr, l %len)
    jnz %res, @pass, @part_2

@part_2
    storel %start, $offset_ptr
    %res =w call $lex_68(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_70(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_71(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_72(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}


function w $lex_73(l %ptr, l %len) {
@start
    %offset =l loadl $offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_69 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    storel %start, $offset_ptr
    %res =w call $lex_70(l %ptr, l %len)
    jnz %res, @pass, @part_1

@part_1
    storel %start, $offset_ptr
    %res =w call $lex_71(l %ptr, l %len)
    jnz %res, @pass, @part_2

@part_2
    storel %start, $offset_ptr
    %res =w call $lex_72(l %ptr, l %len)
    jnz %res, @pass, @part_3

@part_3
    storel %start, $offset_ptr
    %res =w call $lex_73(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_74 (l %ptr, l %len) {
@start
    jmp @loop
@check_eof
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_69(l %ptr, l %len)
    jnz %res, @check_eof, @pass
@pass
    ret 1
}

function l $lex_64 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_65(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_74(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_ident (l %ptr, l %len) {
@start
    %res =w call $lex_64(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_76 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 59)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_75 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_76(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_semi (l %ptr, l %len) {
@start
    %res =w call $lex_75(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_78 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 34)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_81 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 92)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}


function w $lex_82 (l %ptr, l %len) {
@pass
    call $inc_offset()
    ret 1
}

function l $lex_80 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_81(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_82(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_85(l %ptr, l %len) {
@start
    %res =w call $cmp_current(l %ptr, l %len, w 34)
    jnz %res, @pass, @fail
@pass
    call $inc_offset()
    ret 1
@fail
    ret 0
}

function l $lex_87 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 92)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_86(l %ptr, l %len) {
@start
    %res =w call $lex_87(l %ptr, l %len)
    ret %res
}

function l $lex_84 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_85(l %ptr, l %len)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_86(l %ptr, l %len)
    jnz %res, @fail, @pass

@pass
    call $inc_offset()
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_83 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_84(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_79 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    storel %start, $offset_ptr
    %res =w call $lex_80(l %ptr, l %len)
    jnz %res, @pass, @part_1

@part_1
    storel %start, $offset_ptr
    %res =w call $lex_83(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl $offset_ptr

    ret 1
@fail
    storel %start, $offset_ptr
    ret 0
}

function w $lex_88 (l %ptr, l %len) {
@start
    jmp @loop
@check_eof
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_79(l %ptr, l %len)
    jnz %res, @check_eof, @pass
@pass
    ret 1
}

function l $lex_89 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 34)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_77 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_78(l %ptr, l %len)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_88(l %ptr, l %len)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $lex_89(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_string (l %ptr, l %len) {
@start
    %res =w call $lex_77(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

function l $lex_91 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %ptr, l %len, w 64)
    call $inc_offset()
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_90 (l %ptr, l %len) {
@start
    %start =l loadl $offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_91(l %ptr, l %len)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, $offset_ptr
    ret 0
}

function l $lex_at (l %ptr, l %len) {
@start
    %res =w call $lex_90(l %ptr, l %len)
    jnz %res, @pass, @fail
@pass
    %group =l loadl $group_end
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset =l loadl $offset_ptr
    ret %offset
@fail
    ret 0
}

export function :vec $lex(l %ptr, l %len) {
@start
    %tokens =:vec call $new_vec(l 24)
    %total_offset =l copy 0
    jmp @loop
@loop
    %offset =l loadl $offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @end, @check_KEYWORD

@check_KEYWORD
    %res =l call $lex_KEYWORD(l %ptr, l %len)
    jnz %res, @bump_KEYWORD, @check_PARSER
@bump_KEYWORD
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 0, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_PARSER
    %res =l call $lex_PARSER(l %ptr, l %len)
    jnz %res, @bump_PARSER, @check_TOKEN
@bump_PARSER
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 1, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_TOKEN
    %res =l call $lex_TOKEN(l %ptr, l %len)
    jnz %res, @bump_TOKEN, @check_HIGHTLIGHT
@bump_TOKEN
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 2, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_HIGHTLIGHT
    %res =l call $lex_HIGHTLIGHT(l %ptr, l %len)
    jnz %res, @bump_HIGHTLIGHT, @check_FOLD
@bump_HIGHTLIGHT
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 3, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_FOLD
    %res =l call $lex_FOLD(l %ptr, l %len)
    jnz %res, @bump_FOLD, @check_whitespace
@bump_FOLD
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 4, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_whitespace
    %res =l call $lex_whitespace(l %ptr, l %len)
    jnz %res, @bump_whitespace, @check_int
@bump_whitespace
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 5, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_int
    %res =l call $lex_int(l %ptr, l %len)
    jnz %res, @bump_int, @check_colon
@bump_int
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 6, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_colon
    %res =l call $lex_colon(l %ptr, l %len)
    jnz %res, @bump_colon, @check_comma
@bump_colon
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 7, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_comma
    %res =l call $lex_comma(l %ptr, l %len)
    jnz %res, @bump_comma, @check_bar
@bump_comma
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 8, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_bar
    %res =l call $lex_bar(l %ptr, l %len)
    jnz %res, @bump_bar, @check_dot
@bump_bar
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 9, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_dot
    %res =l call $lex_dot(l %ptr, l %len)
    jnz %res, @bump_dot, @check_l_bracket
@bump_dot
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 10, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_l_bracket
    %res =l call $lex_l_bracket(l %ptr, l %len)
    jnz %res, @bump_l_bracket, @check_r_bracket
@bump_l_bracket
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 11, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_r_bracket
    %res =l call $lex_r_bracket(l %ptr, l %len)
    jnz %res, @bump_r_bracket, @check_l_paren
@bump_r_bracket
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 12, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_l_paren
    %res =l call $lex_l_paren(l %ptr, l %len)
    jnz %res, @bump_l_paren, @check_r_paren
@bump_l_paren
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 13, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_r_paren
    %res =l call $lex_r_paren(l %ptr, l %len)
    jnz %res, @bump_r_paren, @check_l_brace
@bump_r_paren
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 14, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_l_brace
    %res =l call $lex_l_brace(l %ptr, l %len)
    jnz %res, @bump_l_brace, @check_r_brace
@bump_l_brace
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 15, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_r_brace
    %res =l call $lex_r_brace(l %ptr, l %len)
    jnz %res, @bump_r_brace, @check_plus
@bump_r_brace
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 16, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_plus
    %res =l call $lex_plus(l %ptr, l %len)
    jnz %res, @bump_plus, @check_eq
@bump_plus
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 17, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_eq
    %res =l call $lex_eq(l %ptr, l %len)
    jnz %res, @bump_eq, @check_ident
@bump_eq
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 18, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_ident
    %res =l call $lex_ident(l %ptr, l %len)
    jnz %res, @bump_ident, @check_semi
@bump_ident
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 19, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_semi
    %res =l call $lex_semi(l %ptr, l %len)
    jnz %res, @bump_semi, @check_string
@bump_semi
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 20, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_string
    %res =l call $lex_string(l %ptr, l %len)
    jnz %res, @bump_string, @check_at
@bump_string
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 21, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop

@check_at
    %res =l call $lex_at(l %ptr, l %len)
    jnz %res, @bump_at, @fail
@bump_at
    %offset =l loadl $offset_ptr
    %end =l add %total_offset, %offset
    %tok =:token call $new_token(l 22, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel 0, $offset_ptr
    storel 0, $group_end
    jmp @loop


@fail
    %end =l add %total_offset, 1
    %tok =:token call $new_token(l 23, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, 1
    %len =l sub %len, 1
    storel 0, $offset_ptr
    storel 0, $group_end
@end
    ret %tokens
}

data $KEYWORD_token_name = { b "KEYWORD", b 0 }
data $KEYWORD_token_name_len = { l 7 }

data $PARSER_token_name = { b "PARSER", b 0 }
data $PARSER_token_name_len = { l 6 }

data $TOKEN_token_name = { b "TOKEN", b 0 }
data $TOKEN_token_name_len = { l 5 }

data $HIGHTLIGHT_token_name = { b "HIGHTLIGHT", b 0 }
data $HIGHTLIGHT_token_name_len = { l 10 }

data $FOLD_token_name = { b "FOLD", b 0 }
data $FOLD_token_name_len = { l 4 }

data $whitespace_token_name = { b "whitespace", b 0 }
data $whitespace_token_name_len = { l 10 }

data $int_token_name = { b "int", b 0 }
data $int_token_name_len = { l 3 }

data $colon_token_name = { b "colon", b 0 }
data $colon_token_name_len = { l 5 }

data $comma_token_name = { b "comma", b 0 }
data $comma_token_name_len = { l 5 }

data $bar_token_name = { b "bar", b 0 }
data $bar_token_name_len = { l 3 }

data $dot_token_name = { b "dot", b 0 }
data $dot_token_name_len = { l 3 }

data $l_bracket_token_name = { b "l_bracket", b 0 }
data $l_bracket_token_name_len = { l 9 }

data $r_bracket_token_name = { b "r_bracket", b 0 }
data $r_bracket_token_name_len = { l 9 }

data $l_paren_token_name = { b "l_paren", b 0 }
data $l_paren_token_name_len = { l 7 }

data $r_paren_token_name = { b "r_paren", b 0 }
data $r_paren_token_name_len = { l 7 }

data $l_brace_token_name = { b "l_brace", b 0 }
data $l_brace_token_name_len = { l 7 }

data $r_brace_token_name = { b "r_brace", b 0 }
data $r_brace_token_name_len = { l 7 }

data $plus_token_name = { b "plus", b 0 }
data $plus_token_name_len = { l 4 }

data $eq_token_name = { b "eq", b 0 }
data $eq_token_name_len = { l 2 }

data $ident_token_name = { b "ident", b 0 }
data $ident_token_name_len = { l 5 }

data $semi_token_name = { b "semi", b 0 }
data $semi_token_name_len = { l 4 }

data $string_token_name = { b "string", b 0 }
data $string_token_name_len = { l 6 }

data $at_token_name = { b "at", b 0 }
data $at_token_name_len = { l 2 }

data $err_token_name = { b "token_error", b 0}


export function :str_slice $token_name(w %kind) {
@KEYWORD
    %ptr =l copy $KEYWORD_token_name
    %len =l copy 7
    %res =w ceqw %kind, 0
    jnz %res, @found, @PARSER

@PARSER
    %ptr =l copy $PARSER_token_name
    %len =l copy 6
    %res =w ceqw %kind, 1
    jnz %res, @found, @TOKEN

@TOKEN
    %ptr =l copy $TOKEN_token_name
    %len =l copy 5
    %res =w ceqw %kind, 2
    jnz %res, @found, @HIGHTLIGHT

@HIGHTLIGHT
    %ptr =l copy $HIGHTLIGHT_token_name
    %len =l copy 10
    %res =w ceqw %kind, 3
    jnz %res, @found, @FOLD

@FOLD
    %ptr =l copy $FOLD_token_name
    %len =l copy 4
    %res =w ceqw %kind, 4
    jnz %res, @found, @whitespace

@whitespace
    %ptr =l copy $whitespace_token_name
    %len =l copy 10
    %res =w ceqw %kind, 5
    jnz %res, @found, @int

@int
    %ptr =l copy $int_token_name
    %len =l copy 3
    %res =w ceqw %kind, 6
    jnz %res, @found, @colon

@colon
    %ptr =l copy $colon_token_name
    %len =l copy 5
    %res =w ceqw %kind, 7
    jnz %res, @found, @comma

@comma
    %ptr =l copy $comma_token_name
    %len =l copy 5
    %res =w ceqw %kind, 8
    jnz %res, @found, @bar

@bar
    %ptr =l copy $bar_token_name
    %len =l copy 3
    %res =w ceqw %kind, 9
    jnz %res, @found, @dot

@dot
    %ptr =l copy $dot_token_name
    %len =l copy 3
    %res =w ceqw %kind, 10
    jnz %res, @found, @l_bracket

@l_bracket
    %ptr =l copy $l_bracket_token_name
    %len =l copy 9
    %res =w ceqw %kind, 11
    jnz %res, @found, @r_bracket

@r_bracket
    %ptr =l copy $r_bracket_token_name
    %len =l copy 9
    %res =w ceqw %kind, 12
    jnz %res, @found, @l_paren

@l_paren
    %ptr =l copy $l_paren_token_name
    %len =l copy 7
    %res =w ceqw %kind, 13
    jnz %res, @found, @r_paren

@r_paren
    %ptr =l copy $r_paren_token_name
    %len =l copy 7
    %res =w ceqw %kind, 14
    jnz %res, @found, @l_brace

@l_brace
    %ptr =l copy $l_brace_token_name
    %len =l copy 7
    %res =w ceqw %kind, 15
    jnz %res, @found, @r_brace

@r_brace
    %ptr =l copy $r_brace_token_name
    %len =l copy 7
    %res =w ceqw %kind, 16
    jnz %res, @found, @plus

@plus
    %ptr =l copy $plus_token_name
    %len =l copy 4
    %res =w ceqw %kind, 17
    jnz %res, @found, @eq

@eq
    %ptr =l copy $eq_token_name
    %len =l copy 2
    %res =w ceqw %kind, 18
    jnz %res, @found, @ident

@ident
    %ptr =l copy $ident_token_name
    %len =l copy 5
    %res =w ceqw %kind, 19
    jnz %res, @found, @semi

@semi
    %ptr =l copy $semi_token_name
    %len =l copy 4
    %res =w ceqw %kind, 20
    jnz %res, @found, @string

@string
    %ptr =l copy $string_token_name
    %len =l copy 6
    %res =w ceqw %kind, 21
    jnz %res, @found, @at

@at
    %ptr =l copy $at_token_name
    %len =l copy 2
    %res =w ceqw %kind, 22
    jnz %res, @found, @err

@err
    %ptr =l copy $err_token_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}
function l $peak_by_id(l %state_ptr, l %offset, w %recover, l %id) {

@check_0
    %res =l ceql %id, 0
    jnz %res, @do_0, @check_1
@do_0
    %ret =l call $peak_0(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_1
    %res =l ceql %id, 1
    jnz %res, @do_1, @check_2
@do_1
    %ret =l call $peak_1(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_2
    %res =l ceql %id, 2
    jnz %res, @do_2, @check_3
@do_2
    %ret =l call $peak_2(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_3
    %res =l ceql %id, 3
    jnz %res, @do_3, @check_4
@do_3
    %ret =l call $peak_3(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_4
    %res =l ceql %id, 4
    jnz %res, @do_4, @check_5
@do_4
    %ret =l call $peak_4(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_5
    %res =l ceql %id, 5
    jnz %res, @do_5, @check_6
@do_5
    %ret =l call $peak_5(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_6
    %res =l ceql %id, 6
    jnz %res, @do_6, @check_7
@do_6
    %ret =l call $peak_6(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_7
    %res =l ceql %id, 7
    jnz %res, @do_7, @check_8
@do_7
    %ret =l call $peak_7(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_8
    %res =l ceql %id, 8
    jnz %res, @do_8, @check_9
@do_8
    %ret =l call $peak_8(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_9
    %res =l ceql %id, 9
    jnz %res, @do_9, @check_10
@do_9
    %ret =l call $peak_9(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_10
    %res =l ceql %id, 10
    jnz %res, @do_10, @check_11
@do_10
    %ret =l call $peak_10(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_11
    %res =l ceql %id, 11
    jnz %res, @do_11, @check_12
@do_11
    %ret =l call $peak_11(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_12
    %res =l ceql %id, 12
    jnz %res, @do_12, @check_13
@do_12
    %ret =l call $peak_12(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_13
    %res =l ceql %id, 13
    jnz %res, @do_13, @check_14
@do_13
    %ret =l call $peak_13(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_14
    %res =l ceql %id, 14
    jnz %res, @do_14, @check_15
@do_14
    %ret =l call $peak_14(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_15
    %res =l ceql %id, 15
    jnz %res, @do_15, @check_16
@do_15
    %ret =l call $peak_15(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_16
    %res =l ceql %id, 16
    jnz %res, @do_16, @check_17
@do_16
    %ret =l call $peak_16(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_17
    %res =l ceql %id, 17
    jnz %res, @do_17, @check_18
@do_17
    %ret =l call $peak_17(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_18
    %res =l ceql %id, 18
    jnz %res, @do_18, @check_19
@do_18
    %ret =l call $peak_18(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_19
    %res =l ceql %id, 19
    jnz %res, @do_19, @check_20
@do_19
    %ret =l call $peak_19(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_20
    %res =l ceql %id, 20
    jnz %res, @do_20, @check_21
@do_20
    %ret =l call $peak_20(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_21
    %res =l ceql %id, 21
    jnz %res, @do_21, @check_22
@do_21
    %ret =l call $peak_21(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_22
    %res =l ceql %id, 22
    jnz %res, @do_22, @check_23
@do_22
    %ret =l call $peak_22(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_23
    %res =l ceql %id, 23
    jnz %res, @do_23, @check_24
@do_23
    %ret =l call $peak_23(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_24
    %res =l ceql %id, 24
    jnz %res, @do_24, @check_25
@do_24
    %ret =l call $peak_24(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_25
    %res =l ceql %id, 25
    jnz %res, @do_25, @check_26
@do_25
    %ret =l call $peak_25(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_26
    %res =l ceql %id, 26
    jnz %res, @do_26, @check_27
@do_26
    %ret =l call $peak_26(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_27
    %res =l ceql %id, 27
    jnz %res, @do_27, @check_28
@do_27
    %ret =l call $peak_27(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_28
    %res =l ceql %id, 28
    jnz %res, @do_28, @check_29
@do_28
    %ret =l call $peak_28(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_29
    %res =l ceql %id, 29
    jnz %res, @do_29, @check_30
@do_29
    %ret =l call $peak_29(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_30
    %res =l ceql %id, 30
    jnz %res, @do_30, @check_31
@do_30
    %ret =l call $peak_30(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_31
    %res =l ceql %id, 31
    jnz %res, @do_31, @check_32
@do_31
    %ret =l call $peak_31(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_32
    %res =l ceql %id, 32
    jnz %res, @do_32, @check_33
@do_32
    %ret =l call $peak_32(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_33
    %res =l ceql %id, 33
    jnz %res, @do_33, @check_34
@do_33
    %ret =l call $peak_33(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_34
    %res =l ceql %id, 34
    jnz %res, @do_34, @check_35
@do_34
    %ret =l call $peak_34(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_35
    %res =l ceql %id, 35
    jnz %res, @do_35, @check_36
@do_35
    %ret =l call $peak_35(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_36
    %res =l ceql %id, 36
    jnz %res, @do_36, @check_37
@do_36
    %ret =l call $peak_36(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_37
    %res =l ceql %id, 37
    jnz %res, @do_37, @check_38
@do_37
    %ret =l call $peak_37(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_38
    %res =l ceql %id, 38
    jnz %res, @do_38, @check_39
@do_38
    %ret =l call $peak_38(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_39
    %res =l ceql %id, 39
    jnz %res, @do_39, @check_40
@do_39
    %ret =l call $peak_39(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_40
    %res =l ceql %id, 40
    jnz %res, @do_40, @check_41
@do_40
    %ret =l call $peak_40(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_41
    %res =l ceql %id, 41
    jnz %res, @do_41, @check_42
@do_41
    %ret =l call $peak_41(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_42
    %res =l ceql %id, 42
    jnz %res, @do_42, @check_43
@do_42
    %ret =l call $peak_42(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_43
    %res =l ceql %id, 43
    jnz %res, @do_43, @check_44
@do_43
    %ret =l call $peak_43(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_44
    %res =l ceql %id, 44
    jnz %res, @do_44, @check_45
@do_44
    %ret =l call $peak_44(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_45
    %res =l ceql %id, 45
    jnz %res, @do_45, @check_46
@do_45
    %ret =l call $peak_45(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_46
    %res =l ceql %id, 46
    jnz %res, @do_46, @check_47
@do_46
    %ret =l call $peak_46(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_47
    %res =l ceql %id, 47
    jnz %res, @do_47, @check_48
@do_47
    %ret =l call $peak_47(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_48
    %res =l ceql %id, 48
    jnz %res, @do_48, @check_49
@do_48
    %ret =l call $peak_48(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_49
    %res =l ceql %id, 49
    jnz %res, @do_49, @check_50
@do_49
    %ret =l call $peak_49(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_50
    %res =l ceql %id, 50
    jnz %res, @do_50, @check_51
@do_50
    %ret =l call $peak_50(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_51
    %res =l ceql %id, 51
    jnz %res, @do_51, @check_52
@do_51
    %ret =l call $peak_51(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_52
    %res =l ceql %id, 52
    jnz %res, @do_52, @check_53
@do_52
    %ret =l call $peak_52(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_53
    %res =l ceql %id, 53
    jnz %res, @do_53, @check_54
@do_53
    %ret =l call $peak_53(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_54
    %res =l ceql %id, 54
    jnz %res, @do_54, @check_55
@do_54
    %ret =l call $peak_54(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_55
    %res =l ceql %id, 55
    jnz %res, @do_55, @check_56
@do_55
    %ret =l call $peak_55(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_56
    %res =l ceql %id, 56
    jnz %res, @do_56, @check_57
@do_56
    %ret =l call $peak_56(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_57
    %res =l ceql %id, 57
    jnz %res, @do_57, @check_58
@do_57
    %ret =l call $peak_57(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_58
    %res =l ceql %id, 58
    jnz %res, @do_58, @check_59
@do_58
    %ret =l call $peak_58(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_59
    %res =l ceql %id, 59
    jnz %res, @do_59, @check_60
@do_59
    %ret =l call $peak_59(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_60
    %res =l ceql %id, 60
    jnz %res, @do_60, @check_61
@do_60
    %ret =l call $peak_60(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_61
    %res =l ceql %id, 61
    jnz %res, @do_61, @check_62
@do_61
    %ret =l call $peak_61(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_62
    %res =l ceql %id, 62
    jnz %res, @do_62, @check_63
@do_62
    %ret =l call $peak_62(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_63
    %res =l ceql %id, 63
    jnz %res, @do_63, @check_64
@do_63
    %ret =l call $peak_63(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_64
    %res =l ceql %id, 64
    jnz %res, @do_64, @check_65
@do_64
    %ret =l call $peak_64(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_65
    %res =l ceql %id, 65
    jnz %res, @do_65, @check_66
@do_65
    %ret =l call $peak_65(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_66
    %res =l ceql %id, 66
    jnz %res, @do_66, @check_67
@do_66
    %ret =l call $peak_66(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_67
    %res =l ceql %id, 67
    jnz %res, @do_67, @check_68
@do_67
    %ret =l call $peak_67(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_68
    %res =l ceql %id, 68
    jnz %res, @do_68, @check_69
@do_68
    %ret =l call $peak_68(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_69
    %res =l ceql %id, 69
    jnz %res, @do_69, @check_70
@do_69
    %ret =l call $peak_69(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_70
    %res =l ceql %id, 70
    jnz %res, @do_70, @err
@do_70
    %ret =l call $peak_70(l %state_ptr, l %offset, w %recover)
    ret %ret

@err
    ret 0
}

# Parse Named
function w $parse_0(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 7)
    %res =l call $parse_22(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_25(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_0(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_22(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_0_data = {l 0, l 13,l 1, l 1}

function :vec $expected_0() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_0_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_1(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_1(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_1_data = {l 0, l 19}

function :vec $expected_1() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_1_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_2(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 1)
    %res =l call $parse_1(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_2(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_1(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_2_data = {l 1, l 1}

function :vec $expected_2() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_2_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_3(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_3(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_3_data = {l 0, l 13}

function :vec $expected_3() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_3_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_4(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_4(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_4_data = {l 0, l 14}

function :vec $expected_4() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_4_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Delim
function w $parse_5(l %state_ptr, w %recover) {
@start
    %res =l call $parse_3(l %state_ptr, w %recover)
    jnz %res, @ret_err, @add_delim
@add_delim
    call $push_delim(l %state_ptr, l 4)
    jmp @try_parse_inner

@try_parse_inner
    %res =l call $parse_0(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @check_missing_item
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@try_parse_close
    %res =l call $parse_4(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_close, @check_missing_close
@bump_err_close
    call $bump_err(l %state_ptr)
    jmp @try_parse_close

@check_missing_item
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %delim_index =l add %delim_stack_len, 2
    %missing_item =l ceql %delim_index, %res
    jnz %missing_item, @missing_item_err, @try_parse_close
@missing_item_err
    %expected =:vec call $expected_0()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_close
@check_missing_close
    %missing_item =l ceql %delim_index, %res
    jnz %missing_item, @missing_item_err, @ret_ok
@missing_close_err
    %expected =:vec call $expected_4()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_err
    ret %res
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
}
function w $peak_5(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_3(l %state_ptr, l %offset, w %recover)
    ret %res
}
data $expected_5_data = {l 0, l 13}

function :vec $expected_5() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_5_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

function w $parse_6(l %state_ptr, w %recover) {
@check_0
    %res =l call $parse_5(l %state_ptr, w %recover)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_2(l %state_ptr, w %recover)
    jnz %res, @ret, @ret
@ret
    ret %res
}
function w $peak_6(l %state_ptr, l %offset, w %recover) {
@check_0
    %res =l call $peak_5(l %state_ptr, l %offset, w %recover)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $peak_2(l %state_ptr, l %offset, w %recover)
    jnz %res, @ret, @ret
@ret
    ret %res
}
data $expected_6_data = {l 0, l 13,l 1, l 1}

function :vec $expected_6() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_6_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_7(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_7(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_7_data = {l 0, l 19}

function :vec $expected_7() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_7_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_8(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 3)
    %res =l call $parse_7(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_8(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_7(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_8_data = {l 1, l 3}

function :vec $expected_8() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_8_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_9(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_9(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_9_data = {l 0, l 10}

function :vec $expected_9() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_9_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_10(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 8
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_10(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 8
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_10_data = {l 0, l 8}

function :vec $expected_10() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_10_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function w $parse_11(l %state_ptr, w %recover) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 0)
    %sep_index =l call $push_delim(l %state_ptr, l 10)
    %res =l call $parse_0(l %state_ptr, w %recover)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_10()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_0()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_10(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_0(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function l $peak_11(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_0(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_11_data = {l 0, l 13,l 1, l 1}

function :vec $expected_11() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_11_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_12(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_12(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_12_data = {l 0, l 13}

function :vec $expected_12() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_12_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_13(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_13(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_13_data = {l 0, l 14}

function :vec $expected_13() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_13_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Delim
function w $parse_14(l %state_ptr, w %recover) {
@start
    %res =l call $parse_12(l %state_ptr, w %recover)
    jnz %res, @ret_err, @add_delim
@add_delim
    call $push_delim(l %state_ptr, l 13)
    jmp @try_parse_inner

@try_parse_inner
    %res =l call $parse_11(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @check_missing_item
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@try_parse_close
    %res =l call $parse_13(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_close, @check_missing_close
@bump_err_close
    call $bump_err(l %state_ptr)
    jmp @try_parse_close

@check_missing_item
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %delim_index =l add %delim_stack_len, 2
    %missing_item =l ceql %delim_index, %res
    jnz %missing_item, @missing_item_err, @try_parse_close
@missing_item_err
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_close
@check_missing_close
    %missing_item =l ceql %delim_index, %res
    jnz %missing_item, @missing_item_err, @ret_ok
@missing_close_err
    %expected =:vec call $expected_13()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_err
    ret %res
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
}
function w $peak_14(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_12(l %state_ptr, l %offset, w %recover)
    ret %res
}
data $expected_14_data = {l 0, l 13}

function :vec $expected_14() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_14_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_15(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 14)
	call $push_long(l %delim_stack_ptr, l 8)

@parse_first
    %res =l call $parse_9(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_9()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_9()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_8(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_8()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_8()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_14(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_14()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_15(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_9(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_15_data = {l 0, l 10}

function :vec $expected_15() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_15_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_16(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 4)
    %res =l call $parse_15(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_16(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_15(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_16_data = {l 1, l 4}

function :vec $expected_16() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_16_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Rep0
function w $parse_17(l %state_ptr, w %recover) {
@start
    call $push_delim(l %state_ptr, l 16)
    %res =l call $parse_16(l %state_ptr, w %recover)
    jnz %res, @ret_err, @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret_ok, @try_parse_inner

@try_parse_inner
    %res =l call $parse_16(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @iter
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@iter
    jnz %res, @ret_ok, @try_parse_inner
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function l $peak_17(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_16(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_17_data = {l 1, l 4}

function :vec $expected_17() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_17_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_18(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 5)
    %res =l call $parse_6(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_17(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_18(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_6(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_18_data = {l 0, l 13,l 1, l 1}

function :vec $expected_18() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_18_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_19(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 17
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_19(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 17
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_19_data = {l 0, l 17}

function :vec $expected_19() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_19_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_20(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 18)

@parse_first
    %res =l call $parse_19(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_18(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_20(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_19(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_20_data = {l 0, l 17}

function :vec $expected_20() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_20_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Rep0
function w $parse_21(l %state_ptr, w %recover) {
@start
    call $push_delim(l %state_ptr, l 20)
    %res =l call $parse_20(l %state_ptr, w %recover)
    jnz %res, @ret_err, @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret_ok, @try_parse_inner

@try_parse_inner
    %res =l call $parse_20(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @iter
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@iter
    jnz %res, @ret_ok, @try_parse_inner
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function l $peak_21(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_20(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_21_data = {l 0, l 17}

function :vec $expected_21() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_21_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_22(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 6)
    %res =l call $parse_18(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_21(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_22(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_18(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_22_data = {l 0, l 13,l 1, l 1}

function :vec $expected_22() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_22_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_23(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 9
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_23(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 9
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_23_data = {l 0, l 9}

function :vec $expected_23() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_23_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_24(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 22)

@parse_first
    %res =l call $parse_23(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_23()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_23()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_22(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_22()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_24(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_23(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_24_data = {l 0, l 9}

function :vec $expected_24() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_24_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Rep0
function w $parse_25(l %state_ptr, w %recover) {
@start
    call $push_delim(l %state_ptr, l 24)
    %res =l call $parse_24(l %state_ptr, w %recover)
    jnz %res, @ret_err, @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret_ok, @try_parse_inner

@try_parse_inner
    %res =l call $parse_24(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @iter
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@iter
    jnz %res, @ret_ok, @try_parse_inner
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function l $peak_25(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_24(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_25_data = {l 0, l 9}

function :vec $expected_25() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_25_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_26(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 7)
    %res =l call $parse_22(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_25(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_26(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_22(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_26_data = {l 0, l 13,l 1, l 1}

function :vec $expected_26() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_26_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_27(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 0
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_27(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 0
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_27_data = {l 0, l 0}

function :vec $expected_27() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_27_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_28(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_28(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_28_data = {l 0, l 19}

function :vec $expected_28() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_28_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_29(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 28)

@parse_first
    %res =l call $parse_27(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_27()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_27()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_28(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_28()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_29(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_27(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_29_data = {l 0, l 0}

function :vec $expected_29() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_29_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_30(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 8)
    %res =l call $parse_29(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_30(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_29(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_30_data = {l 1, l 8}

function :vec $expected_30() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_30_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_31(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 2
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_31(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 2
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_31_data = {l 0, l 2}

function :vec $expected_31() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_31_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_32(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_32(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_32_data = {l 0, l 19}

function :vec $expected_32() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_32_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_33(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 18
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_33(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 18
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_33_data = {l 0, l 18}

function :vec $expected_33() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_33_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_34(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 21
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_34(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 21
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_34_data = {l 0, l 21}

function :vec $expected_34() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_34_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_35(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 6
	call $push_long(l %delim_stack_ptr, l 34)
	call $push_long(l %delim_stack_ptr, l 33)
	call $push_long(l %delim_stack_ptr, l 32)

@parse_first
    %res =l call $parse_31(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_32(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_32()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_32()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_33(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_33()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @check_last
@missing_3
    %expected =:vec call $expected_33()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_34(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @check_last
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_34()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_35(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_31(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_35_data = {l 0, l 2}

function :vec $expected_35() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_35_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_36(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 9)
    %res =l call $parse_35(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_36(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_35(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_36_data = {l 1, l 9}

function :vec $expected_36() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_36_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_37(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 4
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_37(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 4
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_37_data = {l 0, l 4}

function :vec $expected_37() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_37_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_38(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 0)

@parse_first
    %res =l call $parse_37(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_37()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_37()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_0(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_0()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_38(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_37(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_38_data = {l 0, l 4}

function :vec $expected_38() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_38_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_39(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 10)
    %res =l call $parse_0(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_38(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_39(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_0(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_39_data = {l 0, l 13,l 1, l 1}

function :vec $expected_39() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_39_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_40(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 1
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_40(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 1
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_40_data = {l 0, l 1}

function :vec $expected_40() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_40_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_41(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_41(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_41_data = {l 0, l 19}

function :vec $expected_41() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_41_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_42(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 18
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_42(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 18
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_42_data = {l 0, l 18}

function :vec $expected_42() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_42_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_43(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 39)

@parse_first
    %res =l call $parse_42(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_39(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_39()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_43(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_42(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_43_data = {l 0, l 18}

function :vec $expected_43() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_43_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Optional
function w $parse_44(l %state_ptr, w %recover) {
@start
    call $parse_43(l %state_ptr, w %recover)
    ret 0
}
function l $peak_44(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_43(l %state_ptr, l %offset, w %recover)
    ret %res
}

function :vec $expected_44() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function w $parse_45(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 44)
	call $push_long(l %delim_stack_ptr, l 41)

@parse_first
    %res =l call $parse_40(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_40()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_40()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_41(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_41()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_41()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_44(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_44()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_45(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_40(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_45_data = {l 0, l 1}

function :vec $expected_45() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_45_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_46(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 11)
    %res =l call $parse_45(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_46(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_45(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_46_data = {l 1, l 11}

function :vec $expected_46() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_46_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_47(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 15)
    %res =l call $parse_58(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_61(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_47(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_58(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_47_data = {l 1, l 14}

function :vec $expected_47() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_47_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_48(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 8
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_48(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 8
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_48_data = {l 0, l 8}

function :vec $expected_48() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_48_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function w $parse_49(l %state_ptr, w %recover) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 47)
    %sep_index =l call $push_delim(l %state_ptr, l 48)
    %res =l call $parse_47(l %state_ptr, w %recover)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_47()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_48(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_47(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function l $peak_49(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_47(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_49_data = {l 1, l 14}

function :vec $expected_49() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_49_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_50(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_50(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_50_data = {l 0, l 13}

function :vec $expected_50() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_50_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_51(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_51(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_51_data = {l 0, l 14}

function :vec $expected_51() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_51_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Delim
function w $parse_52(l %state_ptr, w %recover) {
@start
    %res =l call $parse_50(l %state_ptr, w %recover)
    jnz %res, @ret_err, @add_delim
@add_delim
    call $push_delim(l %state_ptr, l 51)
    jmp @try_parse_inner

@try_parse_inner
    %res =l call $parse_49(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @check_missing_item
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@try_parse_close
    %res =l call $parse_51(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_close, @check_missing_close
@bump_err_close
    call $bump_err(l %state_ptr)
    jmp @try_parse_close

@check_missing_item
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %delim_index =l add %delim_stack_len, 2
    %missing_item =l ceql %delim_index, %res
    jnz %missing_item, @missing_item_err, @try_parse_close
@missing_item_err
    %expected =:vec call $expected_49()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_close
@check_missing_close
    %missing_item =l ceql %delim_index, %res
    jnz %missing_item, @missing_item_err, @ret_ok
@missing_close_err
    %expected =:vec call $expected_51()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_err
    ret %res
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
}
function w $peak_52(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_50(l %state_ptr, l %offset, w %recover)
    ret %res
}
data $expected_52_data = {l 0, l 13}

function :vec $expected_52() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_52_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_53(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 13)
    %res =l call $parse_52(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_53(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_52(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_53_data = {l 1, l 13}

function :vec $expected_53() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_53_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_54(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 7
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_54(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 7
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_54_data = {l 0, l 7}

function :vec $expected_54() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_54_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_55(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 53)

@parse_first
    %res =l call $parse_54(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_54()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_54()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_53(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_53()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_55(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_54(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_55_data = {l 0, l 7}

function :vec $expected_55() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_55_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Optional
function w $parse_56(l %state_ptr, w %recover) {
@start
    call $parse_55(l %state_ptr, w %recover)
    ret 0
}
function l $peak_56(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_55(l %state_ptr, l %offset, w %recover)
    ret %res
}

function :vec $expected_56() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function w $parse_57(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 56)

@parse_first
    %res =l call $parse_2(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_2()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_2()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_56(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_56()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_57(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_2(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_57_data = {l 1, l 1}

function :vec $expected_57() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_57_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_58(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 14)
    %res =l call $parse_57(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_58(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_57(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_58_data = {l 1, l 14}

function :vec $expected_58() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_58_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_59(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 22
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_59(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 22
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_59_data = {l 0, l 22}

function :vec $expected_59() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_59_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_60(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 21
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_60(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 21
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_60_data = {l 0, l 21}

function :vec $expected_60() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_60_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_61(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 60)

@parse_first
    %res =l call $parse_59(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_59()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_59()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_60(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_60()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_61(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_59(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_61_data = {l 0, l 22}

function :vec $expected_61() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_61_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_62(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 15)
    %res =l call $parse_58(l %state_ptr, w %recover)
    jnz %res, @remove_group, @parse_next
@parse_next
    %res =l call $parse_61(l %state_ptr, w %recover)
    jnz %res, @disolve_group, @exit
@disolve_group
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    call $pop(l %stack_ptr, l 32)
    %outer_group =l call $last(l %stack_ptr, l 32)

    %current_ptr_ptr =l add %current_group, 8
    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr =l loadl %current_ptr_ptr
    %current_size =l mul %current_len, 32

    %outer_ptr_ptr =l add %outer_group, 8
    %outer_len_ptr =l add %outer_group, 16
    %outer_cap_ptr =l add %outer_group, 24
    %outer_len =l loadl %outer_len_ptr
    %outer_len_ptr =l add %outer_group, 16
    %outer_len =l loadl %outer_len_ptr
    %outer_ptr =l loadl %outer_ptr_ptr
    %outer_size =l mul %outer_len, 32

    %new_len =l add %current_len, %outer_len
    %new_cap =l mul %new_len, 2
    %new_size =l mul %new_len, 64
    %new_ptr =l call $malloc(l %new_size)
    %added_ptr =l add %new_ptr, %outer_size

    call $memcpy(l %new_ptr, l %outer_ptr, l %outer_size)
    call $memcpy(l %added_ptr, l %current_ptr, l %current_size)

    call $free(l %outer_ptr)
    call $free(l %current_ptr)

    storel %new_ptr, %outer_ptr_ptr
    storel %new_len, %outer_len_ptr
    storel %new_cap, %outer_cap_ptr

    ret 0
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_62(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_58(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_62_data = {l 1, l 14}

function :vec $expected_62() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_62_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_63(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_63(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_63_data = {l 0, l 3}

function :vec $expected_63() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_63_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_64(l %state_ptr, w %recover) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 47)

@parse_first
    %res =l call $parse_63(l %state_ptr, w %recover)
    jnz %res, @ret_err, @remove_delim_1

@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_63()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_63()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_47(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@ret_err
    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_47()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function l $peak_64(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_63(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_64_data = {l 0, l 3}

function :vec $expected_64() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_64_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_65(l %state_ptr, w %recover) {
@start
    call $enter_group(l %state_ptr, w 16)
    %res =l call $parse_64(l %state_ptr, w %recover)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
}
function l $peak_65(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_64(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_65_data = {l 1, l 16}

function :vec $expected_65() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_65_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

function w $parse_66(l %state_ptr, w %recover) {
@check_0
    %res =l call $parse_30(l %state_ptr, w %recover)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_36(l %state_ptr, w %recover)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_46(l %state_ptr, w %recover)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_65(l %state_ptr, w %recover)
    jnz %res, @ret, @ret
@ret
    ret %res
}
function w $peak_66(l %state_ptr, l %offset, w %recover) {
@check_0
    %res =l call $peak_30(l %state_ptr, l %offset, w %recover)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $peak_36(l %state_ptr, l %offset, w %recover)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $peak_46(l %state_ptr, l %offset, w %recover)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $peak_65(l %state_ptr, l %offset, w %recover)
    jnz %res, @ret, @ret
@ret
    ret %res
}
data $expected_66_data = {l 1, l 8,l 1, l 9,l 1, l 11,l 1, l 16}

function :vec $expected_66() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_66_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_67(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 20
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_67(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 20
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_67_data = {l 0, l 20}

function :vec $expected_67() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_67_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function w $parse_68(l %state_ptr, w %recover) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 66)
    %sep_index =l call $push_delim(l %state_ptr, l 67)
    %res =l call $parse_66(l %state_ptr, w %recover)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_67()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_66()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_67(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_66(l %state_ptr, w %recover)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function l $peak_68(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_66(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_68_data = {l 1, l 8,l 1, l 9,l 1, l 11,l 1, l 16}

function :vec $expected_68() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_68_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_69(l %state_ptr, w %recover) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 5
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_69(l %state_ptr, l %offset, w %recover) {
@start
    %is_eof =w call $is_eof(l %state_ptr) # TODO: CHANGE TO BE EOF AT OFFSET
    jnz %is_eof, @eof, @check_ok
@eof
    ret 2
@check_ok
    %current_kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %res =l ceql %current_kind, 5
    jnz %res, @ret_ok, @recover
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_69_data = {l 0, l 5}

function :vec $expected_69() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_69_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Skip
function w $parse_70(l %state_ptr, w %recover) {
@start
    %after_skipped =l call $after_skipped(l %state_ptr)
    %res =l call $peak_68(l %state_ptr, l %after_skipped, w 1)
    jnz %res, @ret, @parse
@parse
    %skipped =l call $skip(l %state_ptr, l 5)
    %res =l call $parse_68(l %state_ptr, w %recover)
    jnz %skipped, @unskip, @ret
@unskip
    call $unskip(l %state_ptr, l 5)
    ret %res
@ret
    ret %res
}
function l $peak_70(l %state_ptr, l %offset, w %recover) {
@start
    %res =l call $peak_68(l %state_ptr, l %offset, w %recover)
    ret %res
}

data $expected_70_data = {l 1, l 8,l 1, l 9,l 1, l 11,l 1, l 16}

function :vec $expected_70() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_70_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}

data $root_group_id = { w 19 }

export function w $parse(l %state_ptr) {
@start
    jmp @loop
@loop
    %res =l call $parse_70(l %state_ptr, w 1)
    jnz %res, @check_eof, @end
@check_eof
    %is_eof =l ceql %res, 2
    jnz %is_eof, @end, @bump_err
@bump_err
    call $bump_err(l %state_ptr)
    jmp @loop
@end
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret, @expected_eof
@expected_eof
    call $bump_err(l %state_ptr)
    jmp @end
@ret
    ret 1
}

data $_expr_group_name = { b "_expr", b 0 }
data $_expr_group_name_len = { l 5 }

data $named_group_name = { b "named", b 0 }
data $named_group_name_len = { l 5 }

data $_atom_group_name = { b "_atom", b 0 }
data $_atom_group_name_len = { l 5 }

data $call_name_group_name = { b "call_name", b 0 }
data $call_name_group_name_len = { l 9 }

data $call_group_name = { b "call", b 0 }
data $call_group_name_len = { l 4 }

data $member_call_group_name = { b "member_call", b 0 }
data $member_call_group_name_len = { l 11 }

data $seq_group_name = { b "seq", b 0 }
data $seq_group_name_len = { l 3 }

data $choice_group_name = { b "choice", b 0 }
data $choice_group_name_len = { l 6 }

data $kw_def_group_name = { b "kw_def", b 0 }
data $kw_def_group_name_len = { l 6 }

data $token_def_group_name = { b "token_def", b 0 }
data $token_def_group_name_len = { l 9 }

data $fold_stmt_group_name = { b "fold_stmt", b 0 }
data $fold_stmt_group_name_len = { l 9 }

data $parser_def_group_name = { b "parser_def", b 0 }
data $parser_def_group_name_len = { l 10 }

data $_query_group_name = { b "_query", b 0 }
data $_query_group_name_len = { l 6 }

data $child_query_group_name = { b "child_query", b 0 }
data $child_query_group_name_len = { l 11 }

data $group_query_group_name = { b "group_query", b 0 }
data $group_query_group_name_len = { l 11 }

data $labelled_query_group_name = { b "labelled_query", b 0 }
data $labelled_query_group_name_len = { l 14 }

data $highlight_def_group_name = { b "highlight_def", b 0 }
data $highlight_def_group_name_len = { l 13 }

data $_stmt_group_name = { b "_stmt", b 0 }
data $_stmt_group_name_len = { l 5 }

data $_root_group_name = { b "_root", b 0 }
data $_root_group_name_len = { l 5 }

data $root_group_name = { b "root", b 0 }
data $root_group_name_len = { l 4 }

data $err_group_name = { b "group_error", b 0}


export function :str_slice $group_name(w %kind) {
@_expr
    %ptr =l copy $_expr_group_name
    %len =l copy 5
    %res =w ceqw %kind, 0
    jnz %res, @found, @named

@named
    %ptr =l copy $named_group_name
    %len =l copy 5
    %res =w ceqw %kind, 1
    jnz %res, @found, @_atom

@_atom
    %ptr =l copy $_atom_group_name
    %len =l copy 5
    %res =w ceqw %kind, 2
    jnz %res, @found, @call_name

@call_name
    %ptr =l copy $call_name_group_name
    %len =l copy 9
    %res =w ceqw %kind, 3
    jnz %res, @found, @call

@call
    %ptr =l copy $call_group_name
    %len =l copy 4
    %res =w ceqw %kind, 4
    jnz %res, @found, @member_call

@member_call
    %ptr =l copy $member_call_group_name
    %len =l copy 11
    %res =w ceqw %kind, 5
    jnz %res, @found, @seq

@seq
    %ptr =l copy $seq_group_name
    %len =l copy 3
    %res =w ceqw %kind, 6
    jnz %res, @found, @choice

@choice
    %ptr =l copy $choice_group_name
    %len =l copy 6
    %res =w ceqw %kind, 7
    jnz %res, @found, @kw_def

@kw_def
    %ptr =l copy $kw_def_group_name
    %len =l copy 6
    %res =w ceqw %kind, 8
    jnz %res, @found, @token_def

@token_def
    %ptr =l copy $token_def_group_name
    %len =l copy 9
    %res =w ceqw %kind, 9
    jnz %res, @found, @fold_stmt

@fold_stmt
    %ptr =l copy $fold_stmt_group_name
    %len =l copy 9
    %res =w ceqw %kind, 10
    jnz %res, @found, @parser_def

@parser_def
    %ptr =l copy $parser_def_group_name
    %len =l copy 10
    %res =w ceqw %kind, 11
    jnz %res, @found, @_query

@_query
    %ptr =l copy $_query_group_name
    %len =l copy 6
    %res =w ceqw %kind, 12
    jnz %res, @found, @child_query

@child_query
    %ptr =l copy $child_query_group_name
    %len =l copy 11
    %res =w ceqw %kind, 13
    jnz %res, @found, @group_query

@group_query
    %ptr =l copy $group_query_group_name
    %len =l copy 11
    %res =w ceqw %kind, 14
    jnz %res, @found, @labelled_query

@labelled_query
    %ptr =l copy $labelled_query_group_name
    %len =l copy 14
    %res =w ceqw %kind, 15
    jnz %res, @found, @highlight_def

@highlight_def
    %ptr =l copy $highlight_def_group_name
    %len =l copy 13
    %res =w ceqw %kind, 16
    jnz %res, @found, @_stmt

@_stmt
    %ptr =l copy $_stmt_group_name
    %len =l copy 5
    %res =w ceqw %kind, 17
    jnz %res, @found, @_root

@_root
    %ptr =l copy $_root_group_name
    %len =l copy 5
    %res =w ceqw %kind, 18
    jnz %res, @found, @root

@root
    %ptr =l copy $root_group_name
    %len =l copy 4
    %res =w ceqw %kind, 19
    jnz %res, @found, @err

@err
    %ptr =l copy $err_group_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}