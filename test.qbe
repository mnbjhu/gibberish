type :str_slice = { l 2 }
type :vec = { l 3 }
type :token = { l 3 }

type :node = { w 2, l 3 }
type :lexer_state = { l 2, l 1, l 1}

data $match_just = { b "Matched just %d\n", b 0 }
data $eof_just = { b "Eof just %d\n", b 0 }
data $skipped_just = { b "Skipped just %d\n", b 0 }
data $break_just = { b "Break just %d\n", b 0 }
data $err_just = { b "Err just %d\n", b 0 }


# <stack: 3> <tokens: 3> <offset: 1> <delim_stack: 3> <skip: 3>
type :state = { l 3, l 3, l, l 3, l 3 }


function w $is_eof(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %tokens_len =l loadl %tokens_len_ptr

    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %res =w ceql %current, %tokens_len
    ret %res
}

data $skipping_token = { b "Skipping token %u\n", b 0 }

export function w $skip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @already, @push
@already
    ret 0
@push
    call $push_long(l %skip_ptr, l %token_kind)
    ret 1
}

export function w $unskip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @remove, @already
@already
    ret 0
@remove
    %index =l sub %already, 1
    call $remove_long(l %skip_ptr, l %index)
    ret 1
}

function w $remove_long(l %vec, l %index) {
@start
    %len_ptr =l add %vec, 8
    %len     =l loadl %len_ptr
    %ptr     =l loadl %vec

    %len_minus_index =l sub %len, %index
    %len_minus_index =l sub %len_minus_index, 1
    %cpy_size =l mul %len_minus_index, 8

    %offset  =l mul %index, 8
    %dst_ptr =l add %ptr, %offset

    %src_ptr =l add %dst_ptr, 8

    call $memcpy(l %dst_ptr, l %src_ptr, l %cpy_size)

    %len =l sub %len, 1
    storel %len, %len_ptr
    ret 1
}

data $checking_skipped = { b "Checking %u == %u\n" ,b 0}
data $found_skipped = { b "Found %d\n" ,b 0}
data $info_msg = {b "Checking contains long for arr %u, len: %u\n"}

function l $contains_long(l %vec, l %value) {
@start
    %ptr =l loadl %vec
    %len_ptr =l add %vec, 8
    %len =l loadl %len_ptr
    %index =l copy 0
    %item_ptr =l loadl %vec
    jnz %len, @loop, @false
@loop
    %item =l loadl %item_ptr
    %found =l ceql %item, %value
    jnz %found, @true, @iter
@iter
    %index =l add %index, 1
    %item_ptr =l add %item_ptr, 8
    %is_end =l ceql %index, %len
    jnz %is_end, @false, @loop
@false
    ret 0
@true
    %res =l add %index, 1
    ret %res
}

function l $push_delim(l %state_ptr, l %delim) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $push_long(l %delim_stack_ptr, l %delim)
    %delim_len_ptr =l add %delim_stack_ptr, 8
    %delim_len =l loadl %delim_len_ptr
    %res =l add 2, %delim_len
    ret %res
}

function w $pop_delim(l %state_ptr) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $pop(l %delim_stack_ptr, l 8)
    ret 1
}

export function w $bumpN(l %state_ptr, l %n) {
@start
    jmp @loop
@loop
    jnz %n, @iter, @ret
@iter
    %n =l sub %n, 1
    call $bump(l %state_ptr)
    jmp @loop
@ret
    ret 1
}

export function w $enter_group(l %state_ptr, w %group_kind) {
@start
    %stack_ptr =l add %state_ptr, 24
    %new =:node call $new_group_node(w %group_kind)
    call $push(l %stack_ptr, l 32, l %new)
    ret 1
}

function l $current_kind(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %token_ptr =l call $get(l %state_ptr, l 24, l %current)
    %token =l loadl %token_ptr
    ret %token
}

export function l $kind_at_offset(l %state_ptr, l %offset) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %at_offset =l add %current, %offset
    %token_ptr =l call $get(l %state_ptr, l 24, l %at_offset)
    %token =l loadl %token_ptr
    ret %token
}

data $skipped_msg = { b "SKIPPED\n", b 0}
function l $after_skipped(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %current_ptr =l add %state_ptr, 48

    %current =l loadl %current_ptr
    %len =l loadl %tokens_len_ptr

    %offset =l copy 0
    %skip_ptr =l add %state_ptr, 80
@check_eof
    %index =l add %offset, %current
    %is_eof =l ceql %len, %index
    jnz %is_eof, @ret, @loop
@loop
    %kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %is_skipped =l call $contains_long(l %skip_ptr, l %kind)
    jnz %is_skipped, @iter, @ret
@iter
    %offset =l add %offset, 1
    jmp @check_eof
@ret
    ret %offset
}

export function w $exit_group(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24

    %removed =l call $pop(l %stack_ptr, l 32)
    %last =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %last, 8

    call $push(l %children_ptr, l 32, l %removed)
    ret 1
}

export function w $bump_skipped(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)
    %start_ptr =l add %tok_ptr, 8
    %end_ptr =l add %tok_ptr, 16


    %current =l add %current, 1
    storel %current, %current_ptr

    %token =l loadl %tok_ptr
    %start =l loadl %start_ptr
    %end =l loadl %end_ptr

    %new =:node call $new_skipped_node(l %token, l %start, l %end)

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8

    call $push(l %children_ptr, l 32, l %new)

    ret 1
}

export function w $bump(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)
    %start_ptr =l add %tok_ptr, 8
    %end_ptr =l add %tok_ptr, 16


    %current =l add %current, 1
    storel %current, %current_ptr

    %token =l loadl %tok_ptr
    %start =l loadl %start_ptr
    %end =l loadl %end_ptr

    %new =:node call $new_token_node(l %token, l %start, l %end)

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8

    call $push(l %children_ptr, l 32, l %new)

    ret 1
}

export function w $missing(l %state_ptr, l %expected) {
@check_zero_expected
    %ptr =l loadl %expected
    jnz %ptr, @start, @ret
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8
    %missing =:node call $new_missing_node(l %expected)
    call $push(l %children_ptr, l 32, l %missing)
    ret 1
@ret
    ret 1
}

export function w $bump_err(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)

    %current =l add %current, 1
    storel %current, %current_ptr

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %children_ptr =l add %current_group, 8
    %last_child =l call $last(l %children_ptr, l 32)

    %last_child_kind =l loadl %last_child
    %last_is_err =l ceql %last_child_kind, 2
    jnz %last_is_err, @extend_err, @new_error
@extend_err
    %tokens =l add %last_child, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    ret 1
@new_error
    %new_node =:node call $new_error_node()
    %tokens =l add %new_node, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    call $push(l %children_ptr, l 32, l %new_node)
    ret 1
}

export function l $default_state_ptr(l %ptr, l %len) {
@start
    %ptr =:state call $default_state(l %ptr, l %len)
    %res =l call $malloc(l 104)
    call $memcpy(l %res, l %ptr, l 104)
    ret %res
}

export function :state $get_state(l %ptr) {
@start
    %state =l alloc8 104
    blit %ptr, %state, 104
    ret %state
}

export function l $last(l %vec_ptr, l %size) {
@start
    %ptr =l loadl %vec_ptr

    %len_ptr =l add %vec_ptr, 8
    %len =l loadl %len_ptr

    %index =l sub %len, 1

    %offset =l mul %index, %size
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

export function :state $default_state(l %ptr, l %len) {
@start
    %tokens =:vec call $lex(l %ptr, l %len)
    %res =:state call $new_state(:vec %tokens)
    ret %res
}

function :state $new_state(:vec %tokens) {
@start
    %res =l alloc8 104
    %stack_ptr =l add %res, 24
    %offset_ptr =l add %res, 48
    %delim_stack_ptr =l add %res, 56
    %skip_ptr =l add %res, 80

    %root =w loadw $root_group_id
    %group =:node call $new_group_node(w %root)

    %stack =:vec call $new_vec(l 32)
    call $push(l %stack, l 32, l %group)

    %delim_stack =:vec call $new_vec(l 8)
    %skip =:vec call $new_vec(l 8)

    blit %tokens, %res, 24
    blit %stack, %stack_ptr, 24
    blit %delim_stack, %delim_stack_ptr, 24
    blit %skip, %skip_ptr, 24
    storel 0, %offset_ptr

    ret %res
}

data $debug_group = { b "Group { kind: %d, group_kind: %d, ptr: %d, len: %d, cap: %d, }", b 0 }

function w $print_group(:node %group) {
@start
    %group_kind_ptr =l add %group, 4
    %ptr_ptr =l add %group, 8
    %len_ptr =l add %group, 16
    %cap_ptr =l add %group, 24

    %kind =l loadw %group
    %group_kind =l loadw %group_kind_ptr
    %ptr =l loadl %ptr_ptr
    %len =l loadl %len_ptr
    %cap =l loadl %cap_ptr
    ret 1
}

export function l $get(l %vec_ptr, l %size, l %index) {
@start
    %ptr =l loadl %vec_ptr
    %offset =l mul %size, %index
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

export function :node $new_token_node(l %kind, l %start, l %end) {
@start
    %res =l alloc8 32
    %kind_ptr =l add %res, 8
    %start_ptr =l add %res, 16
    %end_ptr =l add %res, 24
    storel 0, %res
    storel %kind, %kind_ptr
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function :node $new_skipped_node(l %kind, l %start, l %end) {
@start
    %res =l alloc8 32
    %kind_ptr =l add %res, 8
    %start_ptr =l add %res, 16
    %end_ptr =l add %res, 24
    storel 4, %res
    storel %kind, %kind_ptr
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function :node $new_missing_node(l %expected) {
@start
    %res =l alloc8 32
    %expected_ptr =l add 8, %res
    blit %expected, %expected_ptr, 24
    storew 3, %res
    ret %res
}

export function :node $new_group_node(w %kind) {
@start
    %res =l alloc8 32
    %group_kind =l add %res, 4
    %vec =:vec call $new_vec(l 32)
    %vec_ptr =l add %res, 8
    %group_kind_ptr =l add 4, %res
    blit %vec, %vec_ptr, 24
    storew 1, %res
    storew %kind, %group_kind_ptr
    ret %res
}



export function :node $new_error_node() {
@start
    %res =l alloc8 32
    %vec =:vec call $new_vec(l 24)
    %vec_ptr =l add %res, 8
    blit %vec, %vec_ptr, 24
    storel 2, %res
    ret %res
}

export function :vec $new_vec(l %item_size) {
@start
    %ptr_ptr =l alloc8 24
    %len_ptr =l add %ptr_ptr, 8
    %cap_ptr =l add %ptr_ptr, 16

    %size =l mul %item_size, 4
    %ptr =l call $malloc(l %size)

    storel %ptr, %ptr_ptr
    storel 0, %len_ptr
    storel 4, %cap_ptr
    ret %ptr_ptr
}


export function :token $new_token(l %kind, l %start, l %end) {
@start
    %res =l alloc8 24
    %start_ptr =l add %res, 8
    %end_ptr =l add %res, 16
    storel %kind, %res
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function l $pop(l %vec, l %value_size) {
@start
  %len_ptr =l add %vec, 8

  %ptr =l loadl %vec
  %len =l loadl %len_ptr

  %len =l sub %len, 1
  storel %len, %len_ptr

  %offset =l mul %len, %value_size
  %item_ptr =l add %offset, %ptr
  ret %item_ptr
}

export function w $push_long(l %vec, l %value) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %bytes =l mul %cap, 8
    %new_ptr =l call $malloc(l %bytes)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %bytes =l mul %len, 8
    call $memcpy(l %new_ptr, l %ptr, l %bytes)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
@push
    %offset =l mul %len, 8
    %item_ptr =l add %ptr, %offset
    %len =l add %len, 1
    storel %len, %len_ptr
    storel %value, %item_ptr
    ret 1
}

export function w $push(l %vec, l %value_size, l %value_ptr) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %size =l mul %cap, %value_size
    %new_ptr =l call $malloc(l %size)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %size =l mul %len, %value_size
    call $memcpy(l %new_ptr, l %ptr, l %size)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
    jmp @push
@push
    %offset =l mul %len, %value_size
    %item_ptr =l add %offset, %ptr
    %len =l add %len, 1
    storel %len, %len_ptr
    call $memcpy(l %item_ptr, l %value_ptr, l %value_size)
    ret 1
}

export function w $free_node(l %n) {
@start
    %kind =w loadw %n
    %is0 =w ceqw %kind, 0
    jnz %is0, @case0, @check1
@check1
    %is1 =w ceqw %kind, 1
    jnz %is1, @case1, @check2
@check2
    %is2 =w ceqw %kind, 2
    jnz %is2, @case2, @check3

@check3
    %is3 =w ceqw %kind, 3
    jnz %is3, @case3, @end


@case0
    jmp @end


@case1
    %childptr_ptr =l add %n, 8
    %childptr =l loadl %childptr_ptr
    %len_ptr =l add %n, 16
    %len =l loadl %len_ptr
    %i =l copy 0
    jmp @loop
@loop
    %cmp =w cultl %i, %len
    jnz %cmp, @loop_body, @loop_done
@loop_body
    %off   =l mul %i, 32
    %child =l add %childptr, %off
    call $free_node(l %child)
    %i =l add %i, 1
    jmp @loop

@loop_done
    call $free(l %childptr)
    jmp @end


@case2
    %tokptr_ptr =l add %n, 8
    %tokptr =l loadl %tokptr_ptr
    call $free(l %tokptr)
    jmp @end


@case3
    %exptr_ptr =l add %n, 8
    %exptr =l loadl %exptr_ptr
    call $free(l %exptr)
    jmp @end


@end
    ret 1
}

export function w $free_state(l %s) {
@start
    %tokptr_ptr =l add %s, 0
    %tokptr     =l loadl %tokptr_ptr
    call $free(l %tokptr)

    %stackptr_ptr =l add %s, 24
    %stackptr     =l loadl %stackptr_ptr

    %stacklen_ptr =l add %s, 32
    %stacklen     =l loadl %stacklen_ptr

    %i =l copy 0
    jmp @stack_loop

@stack_loop
    %cmp =w cultl %i, %stacklen
    jnz %cmp, @stack_loop_body, @stack_loop_done

@stack_loop_body
    %off  =l mul %i, 32
    %node =l add %stackptr, %off

    call $free_node(l %node)

    %i =l add %i, 1
    jmp @stack_loop

@stack_loop_done
    call $free(l %stackptr)

    %delimptr_ptr =l add %s, 56
    %delimptr     =l loadl %delimptr_ptr
    call $free(l %delimptr)

    %skipptr_ptr =l add %s, 80
    %skipptr     =l loadl %skipptr_ptr
    call $free(l %skipptr)

    ret 1
}

function w $cmp_current(l %lexer_state, w %char) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %actual_offset =l add %ptr, %offset
    %current =w loadub %actual_offset
    %res =w ceqw %current, %char
    ret %res
}

function w $inc_offset(l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %offset =l add %offset, 1
    storel %offset, %offset_ptr
    ret 0
}

function w $checkpoint(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %current_len_ptr =l add %current_group, 16
    %len =l loadl %current_len_ptr
    ret %len
}

function w $group_at(l %state_ptr, w %group_kind, l %checkpoint) {
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr_ptr =l add %current_group, 8
    %current_ptr =l loadl %current_ptr_ptr

    %new_group_len =l sub %current_len, %checkpoint
    %new_group_start =l mul %checkpoint, 32
    %new_group_start =l add %new_group_start, %current_ptr
    %new_group_size =l mul %new_group_len, 32

    %new_group_ptr =l call $malloc(l %new_group_size)
    call $memcpy(l %new_group_ptr, l %new_group_start, l %new_group_size)

    %new_group_kind_ptr =l add %new_group_start, 4
    %new_group_ptr_ptr =l add %new_group_start, 8
    %new_group_len_ptr =l add %new_group_start, 16
    %new_group_cap_ptr =l add %new_group_start, 24

    storew 1, %new_group_start
    storew %group_kind, %new_group_kind_ptr
    storel %new_group_ptr, %new_group_ptr_ptr
    storel %new_group_len, %new_group_len_ptr
    storel %new_group_len, %new_group_cap_ptr

    %current_len =l add %checkpoint, 1
    storel %current_len, %current_len_ptr
    ret 1
}

data $named_group_name = { b "named", b 0 }
data $named_group_name_len = { l 5 }

data $_atom_group_name = { b "_atom", b 0 }
data $_atom_group_name_len = { l 5 }

data $call_name_group_name = { b "call_name", b 0 }
data $call_name_group_name_len = { l 9 }

data $named_param_group_name = { b "named_param", b 0 }
data $named_param_group_name_len = { l 11 }

data $args_group_name = { b "args", b 0 }
data $args_group_name_len = { l 4 }

data $call_group_name = { b "call", b 0 }
data $call_group_name_len = { l 4 }

data $member_call_group_name = { b "member_call", b 0 }
data $member_call_group_name_len = { l 11 }

data $seq_group_name = { b "seq", b 0 }
data $seq_group_name_len = { l 3 }

data $choice_group_name = { b "choice", b 0 }
data $choice_group_name_len = { l 6 }

data $_expr_group_name = { b "_expr", b 0 }
data $_expr_group_name_len = { l 5 }

data $_arg_group_name = { b "_arg", b 0 }
data $_arg_group_name_len = { l 4 }

data $kw_def_group_name = { b "kw_def", b 0 }
data $kw_def_group_name_len = { l 6 }

data $token_def_group_name = { b "token_def", b 0 }
data $token_def_group_name_len = { l 9 }

data $fold_stmt_group_name = { b "fold_stmt", b 0 }
data $fold_stmt_group_name_len = { l 9 }

data $parser_def_group_name = { b "parser_def", b 0 }
data $parser_def_group_name_len = { l 10 }

data $child_query_group_name = { b "child_query", b 0 }
data $child_query_group_name_len = { l 11 }

data $group_query_group_name = { b "group_query", b 0 }
data $group_query_group_name_len = { l 11 }

data $label_group_name = { b "label", b 0 }
data $label_group_name_len = { l 5 }

data $labelled_query_group_name = { b "labelled_query", b 0 }
data $labelled_query_group_name_len = { l 14 }

data $_query_group_name = { b "_query", b 0 }
data $_query_group_name_len = { l 6 }

data $highlight_def_group_name = { b "highlight_def", b 0 }
data $highlight_def_group_name_len = { l 13 }

data $_stmt_group_name = { b "_stmt", b 0 }
data $_stmt_group_name_len = { l 5 }

data $_root_group_name = { b "_root", b 0 }
data $_root_group_name_len = { l 5 }

data $root_group_name = { b "root", b 0 }
data $root_group_name_len = { l 4 }

data $unmatched_group_name = { b "unmatched", b 0 }
data $unmatched_group_name_len = { l 9 }

data $err_group_name = { b "group_error", b 0}


export function :str_slice $group_name(w %kind) {
@named
    %ptr =l copy $named_group_name
    %len =l copy 5
    %res =w ceqw %kind, 0
    jnz %res, @found, @_atom

@_atom
    %ptr =l copy $_atom_group_name
    %len =l copy 5
    %res =w ceqw %kind, 1
    jnz %res, @found, @call_name

@call_name
    %ptr =l copy $call_name_group_name
    %len =l copy 9
    %res =w ceqw %kind, 2
    jnz %res, @found, @named_param

@named_param
    %ptr =l copy $named_param_group_name
    %len =l copy 11
    %res =w ceqw %kind, 3
    jnz %res, @found, @args

@args
    %ptr =l copy $args_group_name
    %len =l copy 4
    %res =w ceqw %kind, 4
    jnz %res, @found, @call

@call
    %ptr =l copy $call_group_name
    %len =l copy 4
    %res =w ceqw %kind, 5
    jnz %res, @found, @member_call

@member_call
    %ptr =l copy $member_call_group_name
    %len =l copy 11
    %res =w ceqw %kind, 6
    jnz %res, @found, @seq

@seq
    %ptr =l copy $seq_group_name
    %len =l copy 3
    %res =w ceqw %kind, 7
    jnz %res, @found, @choice

@choice
    %ptr =l copy $choice_group_name
    %len =l copy 6
    %res =w ceqw %kind, 8
    jnz %res, @found, @_expr

@_expr
    %ptr =l copy $_expr_group_name
    %len =l copy 5
    %res =w ceqw %kind, 9
    jnz %res, @found, @_arg

@_arg
    %ptr =l copy $_arg_group_name
    %len =l copy 4
    %res =w ceqw %kind, 10
    jnz %res, @found, @kw_def

@kw_def
    %ptr =l copy $kw_def_group_name
    %len =l copy 6
    %res =w ceqw %kind, 11
    jnz %res, @found, @token_def

@token_def
    %ptr =l copy $token_def_group_name
    %len =l copy 9
    %res =w ceqw %kind, 12
    jnz %res, @found, @fold_stmt

@fold_stmt
    %ptr =l copy $fold_stmt_group_name
    %len =l copy 9
    %res =w ceqw %kind, 13
    jnz %res, @found, @parser_def

@parser_def
    %ptr =l copy $parser_def_group_name
    %len =l copy 10
    %res =w ceqw %kind, 14
    jnz %res, @found, @child_query

@child_query
    %ptr =l copy $child_query_group_name
    %len =l copy 11
    %res =w ceqw %kind, 15
    jnz %res, @found, @group_query

@group_query
    %ptr =l copy $group_query_group_name
    %len =l copy 11
    %res =w ceqw %kind, 16
    jnz %res, @found, @label

@label
    %ptr =l copy $label_group_name
    %len =l copy 5
    %res =w ceqw %kind, 17
    jnz %res, @found, @labelled_query

@labelled_query
    %ptr =l copy $labelled_query_group_name
    %len =l copy 14
    %res =w ceqw %kind, 18
    jnz %res, @found, @_query

@_query
    %ptr =l copy $_query_group_name
    %len =l copy 6
    %res =w ceqw %kind, 19
    jnz %res, @found, @highlight_def

@highlight_def
    %ptr =l copy $highlight_def_group_name
    %len =l copy 13
    %res =w ceqw %kind, 20
    jnz %res, @found, @_stmt

@_stmt
    %ptr =l copy $_stmt_group_name
    %len =l copy 5
    %res =w ceqw %kind, 21
    jnz %res, @found, @_root

@_root
    %ptr =l copy $_root_group_name
    %len =l copy 5
    %res =w ceqw %kind, 22
    jnz %res, @found, @root

@root
    %ptr =l copy $root_group_name
    %len =l copy 4
    %res =w ceqw %kind, 23
    jnz %res, @found, @unmatched

@unmatched
    %ptr =l copy $unmatched_group_name
    %len =l copy 9
    %res =w ceqw %kind, 24
    jnz %res, @found, @err

@err
    %ptr =l copy $err_group_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}
# Exact
function l $lex_3 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 107)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 121)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 119)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 111)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 114)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_6, @fail

@part_6
    %res =w call $cmp_current(l %lexer_state, w 100)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_2 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_3(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_1 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_2(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_5(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_6(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_7(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_4 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_5(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_6(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_7(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_0 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_1(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_4(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_KEYWORD (l %lexer_state) {
@start
    %res =w call $lex_0(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_11 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 112)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 97)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 114)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 115)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 114)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_10 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_11(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_9 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_10(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_13(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_14(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_15(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_12 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_13(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_14(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_15(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_8 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_9(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_12(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_PARSER (l %lexer_state) {
@start
    %res =w call $lex_8(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_19 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 111)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 107)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 110)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_18 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_19(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_17 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_18(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_21(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_22(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_23(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_20 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_21(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_22(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_23(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_16 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_17(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_20(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_TOKEN (l %lexer_state) {
@start
    %res =w call $lex_16(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_27 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 104)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 105)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 103)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 104)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 108)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 105)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_6, @fail

@part_6
    %res =w call $cmp_current(l %lexer_state, w 103)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_7, @fail

@part_7
    %res =w call $cmp_current(l %lexer_state, w 104)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_8, @fail

@part_8
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_26 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_27(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_25 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_26(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_29(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_30(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_31(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_28 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_29(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_30(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_31(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_24 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_25(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_28(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_HIGHTLIGHT (l %lexer_state) {
@start
    %res =w call $lex_24(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_35 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 102)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 111)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 108)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 100)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_34 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_35(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_33 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_34(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_37(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_38(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_39(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_36 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_37(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_38(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_39(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_32 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_33(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_36(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_FOLD (l %lexer_state) {
@start
    %res =w call $lex_32(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# RegexChar
function w $lex_42(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 32)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_43(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 9)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_44(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 10)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_41 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_42(l %lexer_state)
    jnz %res, @pass, @part_1

@part_1
    storel %start, %offset_ptr
    %res =w call $lex_43(l %lexer_state)
    jnz %res, @pass, @part_2

@part_2
    storel %start, %offset_ptr
    %res =w call $lex_44(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_45 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_41(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_41(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_40 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_45(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_whitespace (l %lexer_state) {
@start
    %res =w call $lex_40(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# RegexRange
function w $lex_48(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_47 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_48(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_49 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_47(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_47(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_46 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_49(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_int (l %lexer_state) {
@start
    %res =w call $lex_46(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_51 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 58)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_50 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_51(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_colon (l %lexer_state) {
@start
    %res =w call $lex_50(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_53 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 44)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_52 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_53(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_comma (l %lexer_state) {
@start
    %res =w call $lex_52(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_55 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 124)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_54 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_55(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_bar (l %lexer_state) {
@start
    %res =w call $lex_54(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_57 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 46)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_56 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_57(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_dot (l %lexer_state) {
@start
    %res =w call $lex_56(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_59 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 91)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_58 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_59(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_l_bracket (l %lexer_state) {
@start
    %res =w call $lex_58(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_61 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 93)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_60 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_61(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_r_bracket (l %lexer_state) {
@start
    %res =w call $lex_60(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_63 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 40)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_62 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_63(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_l_paren (l %lexer_state) {
@start
    %res =w call $lex_62(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_65 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 41)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_64 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_65(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_r_paren (l %lexer_state) {
@start
    %res =w call $lex_64(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_67 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 123)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_66 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_67(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_l_brace (l %lexer_state) {
@start
    %res =w call $lex_66(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_69 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 125)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_68 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_69(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_r_brace (l %lexer_state) {
@start
    %res =w call $lex_68(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_71 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 43)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_70 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_71(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_plus (l %lexer_state) {
@start
    %res =w call $lex_70(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_73 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 61)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_72 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_73(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_eq (l %lexer_state) {
@start
    %res =w call $lex_72(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# RegexChar
function w $lex_76(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_77(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_78(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_75 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_76(l %lexer_state)
    jnz %res, @pass, @part_1

@part_1
    storel %start, %offset_ptr
    %res =w call $lex_77(l %lexer_state)
    jnz %res, @pass, @part_2

@part_2
    storel %start, %offset_ptr
    %res =w call $lex_78(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_80(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_81(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_82(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_83(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_79 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_80(l %lexer_state)
    jnz %res, @pass, @part_1

@part_1
    storel %start, %offset_ptr
    %res =w call $lex_81(l %lexer_state)
    jnz %res, @pass, @part_2

@part_2
    storel %start, %offset_ptr
    %res =w call $lex_82(l %lexer_state)
    jnz %res, @pass, @part_3

@part_3
    storel %start, %offset_ptr
    %res =w call $lex_83(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_84 (l %lexer_state) {
@start
    jmp @loop
@check_eof
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_79(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
}

# RegexSeq
function l $lex_74 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_75(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_84(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_ident (l %lexer_state) {
@start
    %res =w call $lex_74(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_86 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 59)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_85 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_86(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_semi (l %lexer_state) {
@start
    %res =w call $lex_85(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_88 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 34)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Exact
function l $lex_91 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 92)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}


function w $lex_92 (l %lexer_state) {
@pass
    call $inc_offset(l %lexer_state)
    ret 1
}

# RegexSeq
function l $lex_90 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_91(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_92(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_95(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 34)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# Exact
function l $lex_97 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 92)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRegexOption
function w $lex_96(l %offset_ptr) {
@start
    %res =w call $lex_97(l %offset_ptr)
    ret %res
}

# RegexNegatedChoice
function l $lex_94 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_95(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_96(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_93 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_94(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_89 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_90(l %lexer_state)
    jnz %res, @pass, @part_1

@part_1
    storel %start, %offset_ptr
    %res =w call $lex_93(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_98 (l %lexer_state) {
@start
    jmp @loop
@check_eof
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_89(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
}

# Exact
function l $lex_99 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 34)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_87 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_88(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_98(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $lex_99(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_string (l %lexer_state) {
@start
    %res =w call $lex_87(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_101 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 64)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_100 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_101(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_at (l %lexer_state) {
@start
    %res =w call $lex_100(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

export function :vec $lex(l %ptr, l %len) {
@start
    %lexer_state =l alloc8 32

    %len_ptr =l add %lexer_state, 8
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %tokens =:vec call $new_vec(l 24)
    %last_was_error =w copy 0
    %total_offset =l copy 0
    jmp @loop
@loop
    jnz %len, @check_KEYWORD, @end

@check_KEYWORD
    storel 0, %group_end_ptr
    %res =l call $lex_KEYWORD(l %lexer_state)
    jnz %res, @check_overflow_KEYWORD, @check_PARSER
@check_overflow_KEYWORD
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_KEYWORD
@bump_KEYWORD
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 0, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_PARSER
    storel 0, %group_end_ptr
    %res =l call $lex_PARSER(l %lexer_state)
    jnz %res, @check_overflow_PARSER, @check_TOKEN
@check_overflow_PARSER
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_PARSER
@bump_PARSER
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 1, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_TOKEN
    storel 0, %group_end_ptr
    %res =l call $lex_TOKEN(l %lexer_state)
    jnz %res, @check_overflow_TOKEN, @check_HIGHTLIGHT
@check_overflow_TOKEN
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_TOKEN
@bump_TOKEN
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 2, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_HIGHTLIGHT
    storel 0, %group_end_ptr
    %res =l call $lex_HIGHTLIGHT(l %lexer_state)
    jnz %res, @check_overflow_HIGHTLIGHT, @check_FOLD
@check_overflow_HIGHTLIGHT
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_HIGHTLIGHT
@bump_HIGHTLIGHT
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 3, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_FOLD
    storel 0, %group_end_ptr
    %res =l call $lex_FOLD(l %lexer_state)
    jnz %res, @check_overflow_FOLD, @check_whitespace
@check_overflow_FOLD
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_FOLD
@bump_FOLD
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 4, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_whitespace
    storel 0, %group_end_ptr
    %res =l call $lex_whitespace(l %lexer_state)
    jnz %res, @check_overflow_whitespace, @check_int
@check_overflow_whitespace
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_whitespace
@bump_whitespace
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 5, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_int
    storel 0, %group_end_ptr
    %res =l call $lex_int(l %lexer_state)
    jnz %res, @check_overflow_int, @check_colon
@check_overflow_int
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_int
@bump_int
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 6, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_colon
    storel 0, %group_end_ptr
    %res =l call $lex_colon(l %lexer_state)
    jnz %res, @check_overflow_colon, @check_comma
@check_overflow_colon
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_colon
@bump_colon
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 7, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_comma
    storel 0, %group_end_ptr
    %res =l call $lex_comma(l %lexer_state)
    jnz %res, @check_overflow_comma, @check_bar
@check_overflow_comma
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_comma
@bump_comma
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 8, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_bar
    storel 0, %group_end_ptr
    %res =l call $lex_bar(l %lexer_state)
    jnz %res, @check_overflow_bar, @check_dot
@check_overflow_bar
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_bar
@bump_bar
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 9, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_dot
    storel 0, %group_end_ptr
    %res =l call $lex_dot(l %lexer_state)
    jnz %res, @check_overflow_dot, @check_l_bracket
@check_overflow_dot
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_dot
@bump_dot
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 10, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_l_bracket
    storel 0, %group_end_ptr
    %res =l call $lex_l_bracket(l %lexer_state)
    jnz %res, @check_overflow_l_bracket, @check_r_bracket
@check_overflow_l_bracket
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_l_bracket
@bump_l_bracket
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 11, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_r_bracket
    storel 0, %group_end_ptr
    %res =l call $lex_r_bracket(l %lexer_state)
    jnz %res, @check_overflow_r_bracket, @check_l_paren
@check_overflow_r_bracket
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_r_bracket
@bump_r_bracket
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 12, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_l_paren
    storel 0, %group_end_ptr
    %res =l call $lex_l_paren(l %lexer_state)
    jnz %res, @check_overflow_l_paren, @check_r_paren
@check_overflow_l_paren
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_l_paren
@bump_l_paren
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 13, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_r_paren
    storel 0, %group_end_ptr
    %res =l call $lex_r_paren(l %lexer_state)
    jnz %res, @check_overflow_r_paren, @check_l_brace
@check_overflow_r_paren
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_r_paren
@bump_r_paren
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 14, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_l_brace
    storel 0, %group_end_ptr
    %res =l call $lex_l_brace(l %lexer_state)
    jnz %res, @check_overflow_l_brace, @check_r_brace
@check_overflow_l_brace
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_l_brace
@bump_l_brace
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 15, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_r_brace
    storel 0, %group_end_ptr
    %res =l call $lex_r_brace(l %lexer_state)
    jnz %res, @check_overflow_r_brace, @check_plus
@check_overflow_r_brace
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_r_brace
@bump_r_brace
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 16, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_plus
    storel 0, %group_end_ptr
    %res =l call $lex_plus(l %lexer_state)
    jnz %res, @check_overflow_plus, @check_eq
@check_overflow_plus
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_plus
@bump_plus
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 17, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_eq
    storel 0, %group_end_ptr
    %res =l call $lex_eq(l %lexer_state)
    jnz %res, @check_overflow_eq, @check_ident
@check_overflow_eq
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_eq
@bump_eq
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 18, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_ident
    storel 0, %group_end_ptr
    %res =l call $lex_ident(l %lexer_state)
    jnz %res, @check_overflow_ident, @check_semi
@check_overflow_ident
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_ident
@bump_ident
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 19, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_semi
    storel 0, %group_end_ptr
    %res =l call $lex_semi(l %lexer_state)
    jnz %res, @check_overflow_semi, @check_string
@check_overflow_semi
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_semi
@bump_semi
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 20, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_string
    storel 0, %group_end_ptr
    %res =l call $lex_string(l %lexer_state)
    jnz %res, @check_overflow_string, @check_at
@check_overflow_string
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_string
@bump_string
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 21, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_at
    storel 0, %group_end_ptr
    %res =l call $lex_at(l %lexer_state)
    jnz %res, @check_overflow_at, @fail
@check_overflow_at
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_at
@bump_at
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 22, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@finish_loop
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop
@fail
    jnz %last_was_error, @fail_again, @fail_first
@fail_first
    %end =l add %total_offset, 1
    %tok =:token call $new_token(l 23, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    jmp @fail_finish
@fail_again
    %end =l add %total_offset, 1
    %last_ptr =l call $last(l %tokens, l 24)
    %last_end_ptr =l add %last_ptr, 16
    %last_end =l loadl %last_end_ptr
    %new_end =l add %last_end, 1
    storel %new_end, %last_end_ptr
    jmp @fail_finish

@fail_finish
    %total_offset =l copy %end
    %ptr =l add %ptr, 1
    %len =l sub %len, 1
    storel 0, %offset_ptr
    storel 0, %group_end_ptr
    %last_was_error =w copy 1
    jmp @loop
    
@end
    ret %tokens
}

data $KEYWORD_token_name = { b "KEYWORD", b 0 }
data $KEYWORD_token_name_len = { l 7 }

data $PARSER_token_name = { b "PARSER", b 0 }
data $PARSER_token_name_len = { l 6 }

data $TOKEN_token_name = { b "TOKEN", b 0 }
data $TOKEN_token_name_len = { l 5 }

data $HIGHTLIGHT_token_name = { b "HIGHTLIGHT", b 0 }
data $HIGHTLIGHT_token_name_len = { l 10 }

data $FOLD_token_name = { b "FOLD", b 0 }
data $FOLD_token_name_len = { l 4 }

data $whitespace_token_name = { b "whitespace", b 0 }
data $whitespace_token_name_len = { l 10 }

data $int_token_name = { b "int", b 0 }
data $int_token_name_len = { l 3 }

data $colon_token_name = { b "colon", b 0 }
data $colon_token_name_len = { l 5 }

data $comma_token_name = { b "comma", b 0 }
data $comma_token_name_len = { l 5 }

data $bar_token_name = { b "bar", b 0 }
data $bar_token_name_len = { l 3 }

data $dot_token_name = { b "dot", b 0 }
data $dot_token_name_len = { l 3 }

data $l_bracket_token_name = { b "l_bracket", b 0 }
data $l_bracket_token_name_len = { l 9 }

data $r_bracket_token_name = { b "r_bracket", b 0 }
data $r_bracket_token_name_len = { l 9 }

data $l_paren_token_name = { b "l_paren", b 0 }
data $l_paren_token_name_len = { l 7 }

data $r_paren_token_name = { b "r_paren", b 0 }
data $r_paren_token_name_len = { l 7 }

data $l_brace_token_name = { b "l_brace", b 0 }
data $l_brace_token_name_len = { l 7 }

data $r_brace_token_name = { b "r_brace", b 0 }
data $r_brace_token_name_len = { l 7 }

data $plus_token_name = { b "plus", b 0 }
data $plus_token_name_len = { l 4 }

data $eq_token_name = { b "eq", b 0 }
data $eq_token_name_len = { l 2 }

data $ident_token_name = { b "ident", b 0 }
data $ident_token_name_len = { l 5 }

data $semi_token_name = { b "semi", b 0 }
data $semi_token_name_len = { l 4 }

data $string_token_name = { b "string", b 0 }
data $string_token_name_len = { l 6 }

data $at_token_name = { b "at", b 0 }
data $at_token_name_len = { l 2 }

data $err_token_name = { b "token_error", b 0}


export function :str_slice $token_name(w %kind) {
@KEYWORD
    %ptr =l copy $KEYWORD_token_name
    %len =l copy 7
    %res =w ceqw %kind, 0
    jnz %res, @found, @PARSER

@PARSER
    %ptr =l copy $PARSER_token_name
    %len =l copy 6
    %res =w ceqw %kind, 1
    jnz %res, @found, @TOKEN

@TOKEN
    %ptr =l copy $TOKEN_token_name
    %len =l copy 5
    %res =w ceqw %kind, 2
    jnz %res, @found, @HIGHTLIGHT

@HIGHTLIGHT
    %ptr =l copy $HIGHTLIGHT_token_name
    %len =l copy 10
    %res =w ceqw %kind, 3
    jnz %res, @found, @FOLD

@FOLD
    %ptr =l copy $FOLD_token_name
    %len =l copy 4
    %res =w ceqw %kind, 4
    jnz %res, @found, @whitespace

@whitespace
    %ptr =l copy $whitespace_token_name
    %len =l copy 10
    %res =w ceqw %kind, 5
    jnz %res, @found, @int

@int
    %ptr =l copy $int_token_name
    %len =l copy 3
    %res =w ceqw %kind, 6
    jnz %res, @found, @colon

@colon
    %ptr =l copy $colon_token_name
    %len =l copy 5
    %res =w ceqw %kind, 7
    jnz %res, @found, @comma

@comma
    %ptr =l copy $comma_token_name
    %len =l copy 5
    %res =w ceqw %kind, 8
    jnz %res, @found, @bar

@bar
    %ptr =l copy $bar_token_name
    %len =l copy 3
    %res =w ceqw %kind, 9
    jnz %res, @found, @dot

@dot
    %ptr =l copy $dot_token_name
    %len =l copy 3
    %res =w ceqw %kind, 10
    jnz %res, @found, @l_bracket

@l_bracket
    %ptr =l copy $l_bracket_token_name
    %len =l copy 9
    %res =w ceqw %kind, 11
    jnz %res, @found, @r_bracket

@r_bracket
    %ptr =l copy $r_bracket_token_name
    %len =l copy 9
    %res =w ceqw %kind, 12
    jnz %res, @found, @l_paren

@l_paren
    %ptr =l copy $l_paren_token_name
    %len =l copy 7
    %res =w ceqw %kind, 13
    jnz %res, @found, @r_paren

@r_paren
    %ptr =l copy $r_paren_token_name
    %len =l copy 7
    %res =w ceqw %kind, 14
    jnz %res, @found, @l_brace

@l_brace
    %ptr =l copy $l_brace_token_name
    %len =l copy 7
    %res =w ceqw %kind, 15
    jnz %res, @found, @r_brace

@r_brace
    %ptr =l copy $r_brace_token_name
    %len =l copy 7
    %res =w ceqw %kind, 16
    jnz %res, @found, @plus

@plus
    %ptr =l copy $plus_token_name
    %len =l copy 4
    %res =w ceqw %kind, 17
    jnz %res, @found, @eq

@eq
    %ptr =l copy $eq_token_name
    %len =l copy 2
    %res =w ceqw %kind, 18
    jnz %res, @found, @ident

@ident
    %ptr =l copy $ident_token_name
    %len =l copy 5
    %res =w ceqw %kind, 19
    jnz %res, @found, @semi

@semi
    %ptr =l copy $semi_token_name
    %len =l copy 4
    %res =w ceqw %kind, 20
    jnz %res, @found, @string

@string
    %ptr =l copy $string_token_name
    %len =l copy 6
    %res =w ceqw %kind, 21
    jnz %res, @found, @at

@at
    %ptr =l copy $at_token_name
    %len =l copy 2
    %res =w ceqw %kind, 22
    jnz %res, @found, @err

@err
    %ptr =l copy $err_token_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}

# Parse Just
function l $parse_2(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 20
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_2(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_2_data = {l 0, l 20}

function :vec $expected_2() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_2_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 0
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_6(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_6_data = {l 0, l 0}

function :vec $expected_6() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_6_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_7(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_7_data = {l 0, l 19}

function :vec $expected_7() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_7_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_5(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 7)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_6()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_6()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_5(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_5_data = {l 0, l 0}

function :vec $expected_5() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_5_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_4(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_5(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 11)
    %res =l call $parse_5(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_4(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_4_data = {l 1, l 11}

function :vec $expected_4() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_4_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_10(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 2
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_10(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_10_data = {l 0, l 2}

function :vec $expected_10() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_10_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_11(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 18
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_11(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_11_data = {l 0, l 18}

function :vec $expected_11() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_11_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_12(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 21
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_12(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 21
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_12_data = {l 0, l 21}

function :vec $expected_12() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_12_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_9(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 6
	call $push_long(l %delim_stack_ptr, l 12)
	call $push_long(l %delim_stack_ptr, l 11)
	call $push_long(l %delim_stack_ptr, l 7)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_10(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_10()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_10()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_11(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @check_last
@missing_3
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_12(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @check_last
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_12()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_9(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_9_data = {l 0, l 2}

function :vec $expected_9() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_9_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_8(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_9(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 12)
    %res =l call $parse_9(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_8(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_8_data = {l 1, l 12}

function :vec $expected_8() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_8_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_15(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 1
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_15(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_15_data = {l 0, l 1}

function :vec $expected_15() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_15_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_24(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_24_data = {l 0, l 13}

function :vec $expected_24() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_24_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_25(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_25_data = {l 0, l 14}

function :vec $expected_25() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_25_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_23(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 25)
	call $push_long(l %delim_stack_ptr, l 19)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_25()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_23(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_23_data = {l 0, l 13}

function :vec $expected_23() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_23_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_26(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_7(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 0)
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_26(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_26_data = {l 1, l 0}

function :vec $expected_26() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_26_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function l $parse_22(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_23(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_26(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res
}
function w $peak_22(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_22_data = {l 0, l 13,l 1, l 0}

function :vec $expected_22() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_22_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_30(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_30(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_30_data = {l 0, l 10}

function :vec $expected_30() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_30_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_31(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_7(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 2)
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_31(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_31_data = {l 1, l 2}

function :vec $expected_31() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_31_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_35(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 8
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_35(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 8
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_35_data = {l 0, l 8}

function :vec $expected_35() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_35_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_43(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 6
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_43(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 6
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_43_data = {l 0, l 6}

function :vec $expected_43() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_43_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function l $parse_42(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_43(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_12(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res
}
function w $peak_42(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 6
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 21
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_42_data = {l 0, l 6,l 0, l 21}

function :vec $expected_42() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_42_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_41(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 42)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_11(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_42(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_41(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_41_data = {l 0, l 18}

function :vec $expected_41() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_41_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function l $parse_40(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_41(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 3, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_40(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_40_data = {l 0, l 18}

function :vec $expected_40() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_40_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function l $parse_47(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_27(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 6, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_47(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_47() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Optional
function l $parse_46(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_47(l %state_ptr, w %recover, l %unmatched_checkpoint)
    ret %res
}
function w $peak_46(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_46() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}


# Parse Just
function l $parse_52(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 17
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_52(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_52_data = {l 0, l 17}

function :vec $expected_52() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_52_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_51(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 21)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_52(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_52()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_52()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_21(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_21()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_51(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_51_data = {l 0, l 17}

function :vec $expected_51() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_51_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Rep0
function l $parse_50(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    call $push_delim(l %state_ptr, l 51)
    %res =l call $parse_51(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret_ok, @try_parse_inner

@try_parse_inner
    %res =l call $parse_51(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @iter
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@iter
    jnz %res, @ret_ok, @try_parse_inner
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_50(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_50() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}


# Parse Rename
function l $parse_49(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_50(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 7, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_49(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_49() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Optional
function l $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_49(l %state_ptr, w %recover, l %unmatched_checkpoint)
    ret %res
}
function w $peak_48(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_48() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function l $parse_45(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 48)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_46(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_start_1, @remove_delim_1
@check_start_1
    %res =l call $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @check_last
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_46()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_46()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_45(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_45() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}


# Parse Just
function l $parse_57(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 9
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_57(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_57_data = {l 0, l 9}

function :vec $expected_57() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_57_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_56(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 20)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_57(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_57()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_57()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_20(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_20()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_56(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_56_data = {l 0, l 9}

function :vec $expected_56() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_56_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Rep0
function l $parse_55(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    call $push_delim(l %state_ptr, l 56)
    %res =l call $parse_56(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret_ok, @try_parse_inner

@try_parse_inner
    %res =l call $parse_56(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @iter
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@iter
    jnz %res, @ret_ok, @try_parse_inner
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_55(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_55() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}


# Parse Rename
function l $parse_54(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_55(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 8, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_54(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_54() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Optional
function l $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_54(l %state_ptr, w %recover, l %unmatched_checkpoint)
    ret %res
}
function w $peak_53(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_53() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function l $parse_44(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 53)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_45(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_start_1, @remove_delim_1
@check_start_1
    %res =l call $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @check_last
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_45()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_45()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_53()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_44(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_44() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Build Choice
function l $parse_39(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_40(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    call $group_at(l %state_ptr, w 0, l %unmatched_checkpoint)
    jmp @check_after_0


@check_after_0
    %res =l call $parse_44(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret, @ret
}
function w $peak_39(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_39() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function l $parse_38(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 39)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_39(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_39()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_38(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_38_data = {l 0, l 19}

function :vec $expected_38() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_38_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_62(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 25)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_25()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_62(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_62_data = {l 0, l 13,l 1, l 0}

function :vec $expected_62() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_62_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_61(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 46)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_62(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_62()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_62()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_46(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_46()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_61(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_61_data = {l 0, l 13,l 1, l 0}

function :vec $expected_61() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_61_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_60(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 48)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_61(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_61()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_61()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_60(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_60_data = {l 0, l 13,l 1, l 0}

function :vec $expected_60() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_60_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_59(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 53)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_60(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_60()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_60()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_53()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_59(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_59_data = {l 0, l 13,l 1, l 0}

function :vec $expected_59() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_59_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_58(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 59)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_59(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_59()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_58(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_58_data = {l 0, l 13}

function :vec $expected_58() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_58_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function l $parse_37(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_38(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_58(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res
}
function w $peak_37(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_37_data = {l 0, l 19,l 0, l 13}

function :vec $expected_37() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_37_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Checkpoint
function l $parse_36(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_37(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %res =l call $parse_37(l %state_ptr, w %recover, l %checkpoint)
    ret %res
@eof
    ret 2
}
function w $peak_36(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_36_data = {l 0, l 19,l 0, l 13}

function :vec $expected_36() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_36_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Sep
function l $parse_34(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 36)
    %sep_index =l call $push_delim(l %state_ptr, l 35)
    %res =l call $parse_36(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_35()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_36()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_35(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_36(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_34(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_34_data = {l 0, l 19,l 0, l 13}

function :vec $expected_34() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_34_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_33(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 25)
	call $push_long(l %delim_stack_ptr, l 34)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_34(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_34()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_34()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_25()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_33(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_33_data = {l 0, l 13}

function :vec $expected_33() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_33_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_32(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_33(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 4)
    %res =l call $parse_33(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_32(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_32_data = {l 1, l 4}

function :vec $expected_32() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_32_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_29(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 32)
	call $push_long(l %delim_stack_ptr, l 31)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_30(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_30()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_30()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_31(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_32(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_32()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_29(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_29_data = {l 0, l 10}

function :vec $expected_29() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_29_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_28(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_29(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 5)
    %res =l call $parse_29(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_28(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_28_data = {l 1, l 5}

function :vec $expected_28() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_28_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Rep0
function l $parse_27(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    call $push_delim(l %state_ptr, l 28)
    %res =l call $parse_28(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret_ok, @try_parse_inner

@try_parse_inner
    %res =l call $parse_28(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @iter
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@iter
    jnz %res, @ret_ok, @try_parse_inner
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_27(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_27() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Fold
function l $parse_21(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_22(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %break_index =l call $push_delim(l %state_ptr, l 27)
    %res =l call $parse_22(l %state_ptr, w %recover, l %unmatched_checkpoint)
    call $pop_delim(l %state_ptr)
    jnz %res, @check_break, @try_parse_next
@check_break
    %is_next =l ceql %res, %break_index
    jnz %is_next, @try_parse_next, @ret_err

@try_parse_next
    %res =l call $parse_27(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_next, @check_next
@bump_err_next
    call $bump_err(l %state_ptr)
    jmp @try_parse_next

@check_next
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 6, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_21(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_21_data = {l 0, l 13,l 1, l 0}

function :vec $expected_21() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_21_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Fold
function l $parse_20(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_21(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %break_index =l call $push_delim(l %state_ptr, l 50)
    %res =l call $parse_21(l %state_ptr, w %recover, l %unmatched_checkpoint)
    call $pop_delim(l %state_ptr)
    jnz %res, @check_break, @try_parse_next
@check_break
    %is_next =l ceql %res, %break_index
    jnz %is_next, @try_parse_next, @ret_err

@try_parse_next
    %res =l call $parse_50(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_next, @check_next
@bump_err_next
    call $bump_err(l %state_ptr)
    jmp @try_parse_next

@check_next
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 7, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_20(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_20_data = {l 0, l 13,l 1, l 0}

function :vec $expected_20() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_20_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Fold
function l $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_20(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %break_index =l call $push_delim(l %state_ptr, l 55)
    %res =l call $parse_20(l %state_ptr, w %recover, l %unmatched_checkpoint)
    call $pop_delim(l %state_ptr)
    jnz %res, @check_break, @try_parse_next
@check_break
    %is_next =l ceql %res, %break_index
    jnz %is_next, @try_parse_next, @ret_err

@try_parse_next
    %res =l call $parse_55(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_next, @check_next
@bump_err_next
    call $bump_err(l %state_ptr)
    jmp @try_parse_next

@check_next
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 8, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_19(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_19_data = {l 0, l 13,l 1, l 0}

function :vec $expected_19() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_19_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_64(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 4
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_64(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_64_data = {l 0, l 4}

function :vec $expected_64() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_64_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_63(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 19)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_64(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_64()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_64()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_63(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_63_data = {l 0, l 4}

function :vec $expected_63() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_63_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Fold
function l $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_19(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %break_index =l call $push_delim(l %state_ptr, l 63)
    %res =l call $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint)
    call $pop_delim(l %state_ptr)
    jnz %res, @check_break, @try_parse_next
@check_break
    %is_next =l ceql %res, %break_index
    jnz %is_next, @try_parse_next, @ret_err

@try_parse_next
    %res =l call $parse_63(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_next, @check_next
@bump_err_next
    call $bump_err(l %state_ptr)
    jmp @try_parse_next

@check_next
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 13, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_18(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_18_data = {l 0, l 13,l 1, l 0}

function :vec $expected_18() {
@start
    %ptr =l call $malloc(l 32)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_18_data, l 32)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 2, %len_ptr
    storel 2, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_17(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 18)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_11(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_17(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_17_data = {l 0, l 18}

function :vec $expected_17() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_17_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Optional
function l $parse_16(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_17(l %state_ptr, w %recover, l %unmatched_checkpoint)
    ret %res
}
function w $peak_16(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_16() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function l $parse_14(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 16)
	call $push_long(l %delim_stack_ptr, l 7)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_15(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_15()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_15()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_16(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_16()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_14(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_14_data = {l 0, l 1}

function :vec $expected_14() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_14_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_13(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_14(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 14)
    %res =l call $parse_14(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_13(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_13_data = {l 1, l 14}

function :vec $expected_13() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_13_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_67(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_67(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_67_data = {l 0, l 3}

function :vec $expected_67() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_67_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_73(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 7
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_73(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_73_data = {l 0, l 7}

function :vec $expected_73() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_73_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function l $parse_76(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 68)
    %sep_index =l call $push_delim(l %state_ptr, l 35)
    %res =l call $parse_68(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_35()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_68()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_35(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_68(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_76(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_76_data = {l 1, l 16}

function :vec $expected_76() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_76_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_75(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 25)
	call $push_long(l %delim_stack_ptr, l 76)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_24()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_76(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_76()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_76()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_25()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_75(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_75_data = {l 0, l 13}

function :vec $expected_75() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_75_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_74(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_75(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 15)
    %res =l call $parse_75(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_74(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_74_data = {l 1, l 15}

function :vec $expected_74() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_74_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_72(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 74)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_73(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_73()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_73()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_74(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_74()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_72(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_72_data = {l 0, l 7}

function :vec $expected_72() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_72_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Optional
function l $parse_71(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_72(l %state_ptr, w %recover, l %unmatched_checkpoint)
    ret %res
}
function w $peak_71(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
function :vec $expected_71() {
@start
    %res =l alloc8 24
    storel 0, %res
    ret %res
}

# Parse Seq
function l $parse_70(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 71)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_26(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_26()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_26()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_71(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_71()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_70(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_70_data = {l 1, l 0}

function :vec $expected_70() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_70_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_69(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_70(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 16)
    %res =l call $parse_70(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_69(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_69_data = {l 1, l 16}

function :vec $expected_69() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_69_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_79(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 22
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_79(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 22
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_79_data = {l 0, l 22}

function :vec $expected_79() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_79_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_78(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 12)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_79(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_79()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_79()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_12(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_12()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_78(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 22
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_78_data = {l 0, l 22}

function :vec $expected_78() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_78_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_77(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_78(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 17)
    %res =l call $parse_78(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_77(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 22
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_77_data = {l 1, l 17}

function :vec $expected_77() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_77_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Fold
function l $parse_68(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_69(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %break_index =l call $push_delim(l %state_ptr, l 77)
    %res =l call $parse_69(l %state_ptr, w %recover, l %unmatched_checkpoint)
    call $pop_delim(l %state_ptr)
    jnz %res, @check_break, @try_parse_next
@check_break
    %is_next =l ceql %res, %break_index
    jnz %is_next, @try_parse_next, @ret_err

@try_parse_next
    %res =l call $parse_77(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_next, @check_next
@bump_err_next
    call $bump_err(l %state_ptr)
    jmp @try_parse_next

@check_next
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 18, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_68(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_68_data = {l 1, l 16}

function :vec $expected_68() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_68_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_66(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 68)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_67(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_67()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_67()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_68(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_68()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_66(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_66_data = {l 0, l 3}

function :vec $expected_66() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_66_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_65(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_66(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 20)
    %res =l call $parse_66(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_65(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_65_data = {l 1, l 20}

function :vec $expected_65() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_65_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function l $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_4(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_8(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_13(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_65(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res
}
function w $peak_3(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_3_data = {l 1, l 11,l 1, l 12,l 1, l 14,l 1, l 20}

function :vec $expected_3() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_3_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}

# Parse Sep
function l $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 3)
    %sep_index =l call $push_delim(l %state_ptr, l 2)
    %res =l call $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_2()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_3()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_2(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_1(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_1_data = {l 1, l 11,l 1, l 12,l 1, l 14,l 1, l 20}

function :vec $expected_1() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_1_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}

# Parse Skip
function l $parse_0(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %skipped =l call $skip(l %state_ptr, l 5)
    %res =l call $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %skipped, @unskip, @ret
@unskip
    call $unskip(l %state_ptr, l 5)
    ret %res
@ret
    ret %res
}
function w $peak_0(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_0_data = {l 1, l 11,l 1, l 12,l 1, l 14,l 1, l 20}

function :vec $expected_0() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_0_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}

function l $peak_by_id(l %state_ptr, l %offset, w %recover, l %id) {

@check_0
    %res =l ceql %id, 0
    jnz %res, @do_0, @check_1
@do_0
    %ret =l call $peak_0(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_1
    %res =l ceql %id, 1
    jnz %res, @do_1, @check_2
@do_1
    %ret =l call $peak_1(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_2
    %res =l ceql %id, 2
    jnz %res, @do_2, @check_3
@do_2
    %ret =l call $peak_2(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_3
    %res =l ceql %id, 3
    jnz %res, @do_3, @check_4
@do_3
    %ret =l call $peak_3(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_4
    %res =l ceql %id, 4
    jnz %res, @do_4, @check_5
@do_4
    %ret =l call $peak_4(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_5
    %res =l ceql %id, 5
    jnz %res, @do_5, @check_6
@do_5
    %ret =l call $peak_5(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_6
    %res =l ceql %id, 6
    jnz %res, @do_6, @check_7
@do_6
    %ret =l call $peak_6(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_7
    %res =l ceql %id, 7
    jnz %res, @do_7, @check_8
@do_7
    %ret =l call $peak_7(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_8
    %res =l ceql %id, 8
    jnz %res, @do_8, @check_9
@do_8
    %ret =l call $peak_8(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_9
    %res =l ceql %id, 9
    jnz %res, @do_9, @check_10
@do_9
    %ret =l call $peak_9(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_10
    %res =l ceql %id, 10
    jnz %res, @do_10, @check_11
@do_10
    %ret =l call $peak_10(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_11
    %res =l ceql %id, 11
    jnz %res, @do_11, @check_12
@do_11
    %ret =l call $peak_11(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_12
    %res =l ceql %id, 12
    jnz %res, @do_12, @check_13
@do_12
    %ret =l call $peak_12(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_13
    %res =l ceql %id, 13
    jnz %res, @do_13, @check_14
@do_13
    %ret =l call $peak_13(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_14
    %res =l ceql %id, 14
    jnz %res, @do_14, @check_15
@do_14
    %ret =l call $peak_14(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_15
    %res =l ceql %id, 15
    jnz %res, @do_15, @check_16
@do_15
    %ret =l call $peak_15(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_16
    %res =l ceql %id, 16
    jnz %res, @do_16, @check_17
@do_16
    %ret =l call $peak_16(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_17
    %res =l ceql %id, 17
    jnz %res, @do_17, @check_18
@do_17
    %ret =l call $peak_17(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_18
    %res =l ceql %id, 18
    jnz %res, @do_18, @check_19
@do_18
    %ret =l call $peak_18(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_19
    %res =l ceql %id, 19
    jnz %res, @do_19, @check_20
@do_19
    %ret =l call $peak_19(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_20
    %res =l ceql %id, 20
    jnz %res, @do_20, @check_21
@do_20
    %ret =l call $peak_20(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_21
    %res =l ceql %id, 21
    jnz %res, @do_21, @check_22
@do_21
    %ret =l call $peak_21(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_22
    %res =l ceql %id, 22
    jnz %res, @do_22, @check_23
@do_22
    %ret =l call $peak_22(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_23
    %res =l ceql %id, 23
    jnz %res, @do_23, @check_24
@do_23
    %ret =l call $peak_23(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_24
    %res =l ceql %id, 24
    jnz %res, @do_24, @check_25
@do_24
    %ret =l call $peak_24(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_25
    %res =l ceql %id, 25
    jnz %res, @do_25, @check_26
@do_25
    %ret =l call $peak_25(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_26
    %res =l ceql %id, 26
    jnz %res, @do_26, @check_27
@do_26
    %ret =l call $peak_26(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_27
    %res =l ceql %id, 27
    jnz %res, @do_27, @check_28
@do_27
    %ret =l call $peak_27(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_28
    %res =l ceql %id, 28
    jnz %res, @do_28, @check_29
@do_28
    %ret =l call $peak_28(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_29
    %res =l ceql %id, 29
    jnz %res, @do_29, @check_30
@do_29
    %ret =l call $peak_29(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_30
    %res =l ceql %id, 30
    jnz %res, @do_30, @check_31
@do_30
    %ret =l call $peak_30(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_31
    %res =l ceql %id, 31
    jnz %res, @do_31, @check_32
@do_31
    %ret =l call $peak_31(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_32
    %res =l ceql %id, 32
    jnz %res, @do_32, @check_33
@do_32
    %ret =l call $peak_32(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_33
    %res =l ceql %id, 33
    jnz %res, @do_33, @check_34
@do_33
    %ret =l call $peak_33(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_34
    %res =l ceql %id, 34
    jnz %res, @do_34, @check_35
@do_34
    %ret =l call $peak_34(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_35
    %res =l ceql %id, 35
    jnz %res, @do_35, @check_36
@do_35
    %ret =l call $peak_35(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_36
    %res =l ceql %id, 36
    jnz %res, @do_36, @check_37
@do_36
    %ret =l call $peak_36(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_37
    %res =l ceql %id, 37
    jnz %res, @do_37, @check_38
@do_37
    %ret =l call $peak_37(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_38
    %res =l ceql %id, 38
    jnz %res, @do_38, @check_39
@do_38
    %ret =l call $peak_38(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_39
    %res =l ceql %id, 39
    jnz %res, @do_39, @check_40
@do_39
    %ret =l call $peak_39(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_40
    %res =l ceql %id, 40
    jnz %res, @do_40, @check_41
@do_40
    %ret =l call $peak_40(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_41
    %res =l ceql %id, 41
    jnz %res, @do_41, @check_42
@do_41
    %ret =l call $peak_41(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_42
    %res =l ceql %id, 42
    jnz %res, @do_42, @check_43
@do_42
    %ret =l call $peak_42(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_43
    %res =l ceql %id, 43
    jnz %res, @do_43, @check_44
@do_43
    %ret =l call $peak_43(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_44
    %res =l ceql %id, 44
    jnz %res, @do_44, @check_45
@do_44
    %ret =l call $peak_44(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_45
    %res =l ceql %id, 45
    jnz %res, @do_45, @check_46
@do_45
    %ret =l call $peak_45(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_46
    %res =l ceql %id, 46
    jnz %res, @do_46, @check_47
@do_46
    %ret =l call $peak_46(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_47
    %res =l ceql %id, 47
    jnz %res, @do_47, @check_48
@do_47
    %ret =l call $peak_47(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_48
    %res =l ceql %id, 48
    jnz %res, @do_48, @check_49
@do_48
    %ret =l call $peak_48(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_49
    %res =l ceql %id, 49
    jnz %res, @do_49, @check_50
@do_49
    %ret =l call $peak_49(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_50
    %res =l ceql %id, 50
    jnz %res, @do_50, @check_51
@do_50
    %ret =l call $peak_50(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_51
    %res =l ceql %id, 51
    jnz %res, @do_51, @check_52
@do_51
    %ret =l call $peak_51(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_52
    %res =l ceql %id, 52
    jnz %res, @do_52, @check_53
@do_52
    %ret =l call $peak_52(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_53
    %res =l ceql %id, 53
    jnz %res, @do_53, @check_54
@do_53
    %ret =l call $peak_53(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_54
    %res =l ceql %id, 54
    jnz %res, @do_54, @check_55
@do_54
    %ret =l call $peak_54(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_55
    %res =l ceql %id, 55
    jnz %res, @do_55, @check_56
@do_55
    %ret =l call $peak_55(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_56
    %res =l ceql %id, 56
    jnz %res, @do_56, @check_57
@do_56
    %ret =l call $peak_56(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_57
    %res =l ceql %id, 57
    jnz %res, @do_57, @check_58
@do_57
    %ret =l call $peak_57(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_58
    %res =l ceql %id, 58
    jnz %res, @do_58, @check_59
@do_58
    %ret =l call $peak_58(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_59
    %res =l ceql %id, 59
    jnz %res, @do_59, @check_60
@do_59
    %ret =l call $peak_59(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_60
    %res =l ceql %id, 60
    jnz %res, @do_60, @check_61
@do_60
    %ret =l call $peak_60(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_61
    %res =l ceql %id, 61
    jnz %res, @do_61, @check_62
@do_61
    %ret =l call $peak_61(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_62
    %res =l ceql %id, 62
    jnz %res, @do_62, @check_63
@do_62
    %ret =l call $peak_62(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_63
    %res =l ceql %id, 63
    jnz %res, @do_63, @check_64
@do_63
    %ret =l call $peak_63(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_64
    %res =l ceql %id, 64
    jnz %res, @do_64, @check_65
@do_64
    %ret =l call $peak_64(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_65
    %res =l ceql %id, 65
    jnz %res, @do_65, @check_66
@do_65
    %ret =l call $peak_65(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_66
    %res =l ceql %id, 66
    jnz %res, @do_66, @check_67
@do_66
    %ret =l call $peak_66(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_67
    %res =l ceql %id, 67
    jnz %res, @do_67, @check_68
@do_67
    %ret =l call $peak_67(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_68
    %res =l ceql %id, 68
    jnz %res, @do_68, @check_69
@do_68
    %ret =l call $peak_68(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_69
    %res =l ceql %id, 69
    jnz %res, @do_69, @check_70
@do_69
    %ret =l call $peak_69(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_70
    %res =l ceql %id, 70
    jnz %res, @do_70, @check_71
@do_70
    %ret =l call $peak_70(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_71
    %res =l ceql %id, 71
    jnz %res, @do_71, @check_72
@do_71
    %ret =l call $peak_71(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_72
    %res =l ceql %id, 72
    jnz %res, @do_72, @check_73
@do_72
    %ret =l call $peak_72(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_73
    %res =l ceql %id, 73
    jnz %res, @do_73, @check_74
@do_73
    %ret =l call $peak_73(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_74
    %res =l ceql %id, 74
    jnz %res, @do_74, @check_75
@do_74
    %ret =l call $peak_74(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_75
    %res =l ceql %id, 75
    jnz %res, @do_75, @check_76
@do_75
    %ret =l call $peak_75(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_76
    %res =l ceql %id, 76
    jnz %res, @do_76, @check_77
@do_76
    %ret =l call $peak_76(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_77
    %res =l ceql %id, 77
    jnz %res, @do_77, @check_78
@do_77
    %ret =l call $peak_77(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_78
    %res =l ceql %id, 78
    jnz %res, @do_78, @check_79
@do_78
    %ret =l call $peak_78(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_79
    %res =l ceql %id, 79
    jnz %res, @do_79, @err
@do_79
    %ret =l call $peak_79(l %state_ptr, l %offset, w %recover)
    ret %ret

@err
    ret 0
}

data $root_group_id = { w 23 }

export function w $parse(l %state_ptr) {
@start
    jmp @loop
@loop
    %res =l call $parse_0(l %state_ptr, w 1, l 0)
    jnz %res, @check_eof, @end
@check_eof
    %is_eof =l ceql %res, 2
    jnz %is_eof, @missing, @bump_err
@missing
    %expected =:vec call $expected_0()
    call $missing(l %state_ptr, l %expected)
    jmp @end
@bump_err
    call $bump_err(l %state_ptr)
    jmp @loop
@end
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret, @expected_eof
@expected_eof
    call $bump_err(l %state_ptr)
    jmp @end
@ret
    ret 1
}
