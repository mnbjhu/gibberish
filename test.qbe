type :str_slice = { l 2 }
type :vec = { l 3 }
type :token = { l 3 }

type :node = { w 2, l 3 }
type :lexer_state = { l 2, l 1, l 1}

data $match_just = { b "Matched just %d\n", b 0 }
data $eof_just = { b "Eof just %d\n", b 0 }
data $skipped_just = { b "Skipped just %d\n", b 0 }
data $break_just = { b "Break just %d\n", b 0 }
data $err_just = { b "Err just %d\n", b 0 }


# <stack: 3> <tokens: 3> <offset: 1> <delim_stack: 3> <skip: 3>
type :state = { l 3, l 3, l, l 3, l 3 }


function w $is_eof(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %tokens_len =l loadl %tokens_len_ptr

    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %res =w ceql %current, %tokens_len
    ret %res
}

data $skipping_token = { b "Skipping token %u\n", b 0 }

export function w $skip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @already, @push
@already
    ret 0
@push
    call $push_long(l %skip_ptr, l %token_kind)
    ret 1
}

export function w $unskip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @remove, @already
@already
    ret 0
@remove
    %index =l sub %already, 1
    call $remove_long(l %skip_ptr, l %index)
    ret 1
}

function w $remove_long(l %vec, l %index) {
@start
    %len_ptr =l add %vec, 8
    %len     =l loadl %len_ptr
    %ptr     =l loadl %vec

    %len_minus_index =l sub %len, %index
    %len_minus_index =l sub %len_minus_index, 1
    %cpy_size =l mul %len_minus_index, 8

    %offset  =l mul %index, 8
    %dst_ptr =l add %ptr, %offset

    %src_ptr =l add %dst_ptr, 8

    call $memcpy(l %dst_ptr, l %src_ptr, l %cpy_size)

    %len =l sub %len, 1
    storel %len, %len_ptr
    ret 1
}

data $checking_skipped = { b "Checking %u == %u\n" ,b 0}
data $found_skipped = { b "Found %d\n" ,b 0}
data $info_msg = {b "Checking contains long for arr %u, len: %u\n"}

function l $contains_long(l %vec, l %value) {
@start
    %ptr =l loadl %vec
    %len_ptr =l add %vec, 8
    %len =l loadl %len_ptr
    %index =l copy 0
    %item_ptr =l loadl %vec
    jnz %len, @loop, @false
@loop
    %item =l loadl %item_ptr
    %found =l ceql %item, %value
    jnz %found, @true, @iter
@iter
    %index =l add %index, 1
    %item_ptr =l add %item_ptr, 8
    %is_end =l ceql %index, %len
    jnz %is_end, @false, @loop
@false
    ret 0
@true
    %res =l add %index, 1
    ret %res
}

function l $push_delim(l %state_ptr, l %delim) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $push_long(l %delim_stack_ptr, l %delim)
    %delim_len_ptr =l add %delim_stack_ptr, 8
    %delim_len =l loadl %delim_len_ptr
    %res =l add 2, %delim_len
    ret %res
}

function w $pop_delim(l %state_ptr) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $pop(l %delim_stack_ptr, l 8)
    ret 1
}

export function w $bumpN(l %state_ptr, l %n) {
@start
    jmp @loop
@loop
    jnz %n, @iter, @ret
@iter
    %n =l sub %n, 1
    call $bump(l %state_ptr)
    jmp @loop
@ret
    ret 1
}

export function w $enter_group(l %state_ptr, w %group_kind) {
@start
    %stack_ptr =l add %state_ptr, 24
    %new =:node call $new_group_node(w %group_kind)
    call $push(l %stack_ptr, l 32, l %new)
    ret 1
}

function l $current_kind(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %token_ptr =l call $get(l %state_ptr, l 24, l %current)
    %token =l loadl %token_ptr
    ret %token
}

export function l $kind_at_offset(l %state_ptr, l %offset) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %at_offset =l add %current, %offset
    %token_ptr =l call $get(l %state_ptr, l 24, l %at_offset)
    %token =l loadl %token_ptr
    ret %token
}

data $skipped_msg = { b "SKIPPED\n", b 0}
function l $after_skipped(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %current_ptr =l add %state_ptr, 48

    %current =l loadl %current_ptr
    %len =l loadl %tokens_len_ptr

    %offset =l copy 0
    %skip_ptr =l add %state_ptr, 80
@check_eof
    %index =l add %offset, %current
    %is_eof =l ceql %len, %index
    jnz %is_eof, @ret, @loop
@loop
    %kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %is_skipped =l call $contains_long(l %skip_ptr, l %kind)
    jnz %is_skipped, @iter, @ret
@iter
    %offset =l add %offset, 1
    jmp @check_eof
@ret
    ret %offset
}

export function w $exit_group(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24

    %removed =l call $pop(l %stack_ptr, l 32)
    %last =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %last, 8

    call $push(l %children_ptr, l 32, l %removed)
    ret 1
}

export function w $bump_skipped(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)
    %start_ptr =l add %tok_ptr, 8
    %end_ptr =l add %tok_ptr, 16


    %current =l add %current, 1
    storel %current, %current_ptr

    %token =l loadl %tok_ptr
    %start =l loadl %start_ptr
    %end =l loadl %end_ptr

    %new =:node call $new_skipped_node(l %token, l %start, l %end)

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8

    call $push(l %children_ptr, l 32, l %new)

    ret 1
}

export function w $bump(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)
    %start_ptr =l add %tok_ptr, 8
    %end_ptr =l add %tok_ptr, 16


    %current =l add %current, 1
    storel %current, %current_ptr

    %token =l loadl %tok_ptr
    %start =l loadl %start_ptr
    %end =l loadl %end_ptr

    %new =:node call $new_token_node(l %token, l %start, l %end)

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8

    call $push(l %children_ptr, l 32, l %new)

    ret 1
}

export function w $missing(l %state_ptr, l %expected) {
@check_zero_expected
    %ptr =l loadl %expected
    jnz %ptr, @start, @ret
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8
    %missing =:node call $new_missing_node(l %expected)
    call $push(l %children_ptr, l 32, l %missing)
    ret 1
@ret
    ret 1
}

export function w $bump_err(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)

    %current =l add %current, 1
    storel %current, %current_ptr

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %children_ptr =l add %current_group, 8
    %last_child =l call $last(l %children_ptr, l 32)

    %last_child_kind =l loadl %last_child
    %last_is_err =l ceql %last_child_kind, 2
    jnz %last_is_err, @extend_err, @new_error
@extend_err
    %tokens =l add %last_child, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    ret 1
@new_error
    %new_node =:node call $new_error_node()
    %tokens =l add %new_node, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    call $push(l %children_ptr, l 32, l %new_node)
    ret 1
}

export function l $default_state_ptr(l %ptr, l %len) {
@start
    %ptr =:state call $default_state(l %ptr, l %len)
    %res =l call $malloc(l 104)
    call $memcpy(l %res, l %ptr, l 104)
    ret %res
}

export function :state $get_state(l %ptr) {
@start
    %state =l alloc8 104
    blit %ptr, %state, 104
    ret %state
}

export function l $last(l %vec_ptr, l %size) {
@start
    %ptr =l loadl %vec_ptr

    %len_ptr =l add %vec_ptr, 8
    %len =l loadl %len_ptr

    %index =l sub %len, 1

    %offset =l mul %index, %size
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

export function :state $default_state(l %ptr, l %len) {
@start
    %tokens =:vec call $lex(l %ptr, l %len)
    %res =:state call $new_state(:vec %tokens)
    ret %res
}

function :state $new_state(:vec %tokens) {
@start
    %res =l alloc8 104
    %stack_ptr =l add %res, 24
    %offset_ptr =l add %res, 48
    %delim_stack_ptr =l add %res, 56
    %skip_ptr =l add %res, 80

    %root =w loadw $root_group_id
    %group =:node call $new_group_node(w %root)

    %stack =:vec call $new_vec(l 32)
    call $push(l %stack, l 32, l %group)

    %delim_stack =:vec call $new_vec(l 8)
    %skip =:vec call $new_vec(l 8)

    blit %tokens, %res, 24
    blit %stack, %stack_ptr, 24
    blit %delim_stack, %delim_stack_ptr, 24
    blit %skip, %skip_ptr, 24
    storel 0, %offset_ptr

    ret %res
}

data $debug_group = { b "Group { kind: %d, group_kind: %d, ptr: %d, len: %d, cap: %d, }", b 0 }

function w $print_group(:node %group) {
@start
    %group_kind_ptr =l add %group, 4
    %ptr_ptr =l add %group, 8
    %len_ptr =l add %group, 16
    %cap_ptr =l add %group, 24

    %kind =l loadw %group
    %group_kind =l loadw %group_kind_ptr
    %ptr =l loadl %ptr_ptr
    %len =l loadl %len_ptr
    %cap =l loadl %cap_ptr
    ret 1
}

export function l $get(l %vec_ptr, l %size, l %index) {
@start
    %ptr =l loadl %vec_ptr
    %offset =l mul %size, %index
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

export function :node $new_token_node(l %kind, l %start, l %end) {
@start
    %res =l alloc8 32
    %kind_ptr =l add %res, 8
    %start_ptr =l add %res, 16
    %end_ptr =l add %res, 24
    storel 0, %res
    storel %kind, %kind_ptr
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function :node $new_skipped_node(l %kind, l %start, l %end) {
@start
    %res =l alloc8 32
    %kind_ptr =l add %res, 8
    %start_ptr =l add %res, 16
    %end_ptr =l add %res, 24
    storel 4, %res
    storel %kind, %kind_ptr
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function :node $new_missing_node(l %expected) {
@start
    %res =l alloc8 32
    %expected_ptr =l add 8, %res
    blit %expected, %expected_ptr, 24
    storew 3, %res
    ret %res
}

export function :node $new_group_node(w %kind) {
@start
    %res =l alloc8 32
    %group_kind =l add %res, 4
    %vec =:vec call $new_vec(l 32)
    %vec_ptr =l add %res, 8
    %group_kind_ptr =l add 4, %res
    blit %vec, %vec_ptr, 24
    storew 1, %res
    storew %kind, %group_kind_ptr
    ret %res
}



export function :node $new_error_node() {
@start
    %res =l alloc8 32
    %vec =:vec call $new_vec(l 24)
    %vec_ptr =l add %res, 8
    blit %vec, %vec_ptr, 24
    storel 2, %res
    ret %res
}

export function :vec $new_vec(l %item_size) {
@start
    %ptr_ptr =l alloc8 24
    %len_ptr =l add %ptr_ptr, 8
    %cap_ptr =l add %ptr_ptr, 16

    %size =l mul %item_size, 4
    %ptr =l call $malloc(l %size)

    storel %ptr, %ptr_ptr
    storel 0, %len_ptr
    storel 4, %cap_ptr
    ret %ptr_ptr
}


export function :token $new_token(l %kind, l %start, l %end) {
@start
    %res =l alloc8 24
    %start_ptr =l add %res, 8
    %end_ptr =l add %res, 16
    storel %kind, %res
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function l $pop(l %vec, l %value_size) {
@start
  %len_ptr =l add %vec, 8

  %ptr =l loadl %vec
  %len =l loadl %len_ptr

  %len =l sub %len, 1
  storel %len, %len_ptr

  %offset =l mul %len, %value_size
  %item_ptr =l add %offset, %ptr
  ret %item_ptr
}

export function w $push_long(l %vec, l %value) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %bytes =l mul %cap, 8
    %new_ptr =l call $malloc(l %bytes)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %bytes =l mul %len, 8
    call $memcpy(l %new_ptr, l %ptr, l %bytes)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
@push
    %offset =l mul %len, 8
    %item_ptr =l add %ptr, %offset
    %len =l add %len, 1
    storel %len, %len_ptr
    storel %value, %item_ptr
    ret 1
}

export function w $push(l %vec, l %value_size, l %value_ptr) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %size =l mul %cap, %value_size
    %new_ptr =l call $malloc(l %size)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %size =l mul %len, %value_size
    call $memcpy(l %new_ptr, l %ptr, l %size)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
    jmp @push
@push
    %offset =l mul %len, %value_size
    %item_ptr =l add %offset, %ptr
    %len =l add %len, 1
    storel %len, %len_ptr
    call $memcpy(l %item_ptr, l %value_ptr, l %value_size)
    ret 1
}

export function w $free_node(l %n) {
@start
    %kind =w loadw %n
    %is0 =w ceqw %kind, 0
    jnz %is0, @case0, @check1
@check1
    %is1 =w ceqw %kind, 1
    jnz %is1, @case1, @check2
@check2
    %is2 =w ceqw %kind, 2
    jnz %is2, @case2, @check3

@check3
    %is3 =w ceqw %kind, 3
    jnz %is3, @case3, @end


@case0
    jmp @end


@case1
    %childptr_ptr =l add %n, 8
    %childptr =l loadl %childptr_ptr
    %len_ptr =l add %n, 16
    %len =l loadl %len_ptr
    %i =l copy 0
    jmp @loop
@loop
    %cmp =w cultl %i, %len
    jnz %cmp, @loop_body, @loop_done
@loop_body
    %off   =l mul %i, 32
    %child =l add %childptr, %off
    call $free_node(l %child)
    %i =l add %i, 1
    jmp @loop

@loop_done
    call $free(l %childptr)
    jmp @end


@case2
    %tokptr_ptr =l add %n, 8
    %tokptr =l loadl %tokptr_ptr
    call $free(l %tokptr)
    jmp @end


@case3
    %exptr_ptr =l add %n, 8
    %exptr =l loadl %exptr_ptr
    call $free(l %exptr)
    jmp @end


@end
    ret 1
}

export function w $free_state(l %s) {
@start
    %tokptr_ptr =l add %s, 0
    %tokptr     =l loadl %tokptr_ptr
    call $free(l %tokptr)

    %stackptr_ptr =l add %s, 24
    %stackptr     =l loadl %stackptr_ptr

    %stacklen_ptr =l add %s, 32
    %stacklen     =l loadl %stacklen_ptr

    %i =l copy 0
    jmp @stack_loop

@stack_loop
    %cmp =w cultl %i, %stacklen
    jnz %cmp, @stack_loop_body, @stack_loop_done

@stack_loop_body
    %off  =l mul %i, 32
    %node =l add %stackptr, %off

    call $free_node(l %node)

    %i =l add %i, 1
    jmp @stack_loop

@stack_loop_done
    call $free(l %stackptr)

    %delimptr_ptr =l add %s, 56
    %delimptr     =l loadl %delimptr_ptr
    call $free(l %delimptr)

    %skipptr_ptr =l add %s, 80
    %skipptr     =l loadl %skipptr_ptr
    call $free(l %skipptr)

    ret 1
}

function w $cmp_current(l %lexer_state, w %char) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %actual_offset =l add %ptr, %offset
    %current =w loadub %actual_offset
    %res =w ceqw %current, %char
    ret %res
}

function w $inc_offset(l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %offset =l add %offset, 1
    storel %offset, %offset_ptr
    ret 0
}

function w $checkpoint(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %current_len_ptr =l add %current_group, 16
    %len =l loadl %current_len_ptr
    ret %len
}

function w $group_at(l %state_ptr, w %group_kind, l %checkpoint) {
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr_ptr =l add %current_group, 8
    %current_ptr =l loadl %current_ptr_ptr

    %new_group_len =l sub %current_len, %checkpoint
    %new_group_start =l mul %checkpoint, 32
    %new_group_start =l add %new_group_start, %current_ptr
    %new_group_size =l mul %new_group_len, 32

    %new_group_ptr =l call $malloc(l %new_group_size)
    call $memcpy(l %new_group_ptr, l %new_group_start, l %new_group_size)

    %new_group_kind_ptr =l add %new_group_start, 4
    %new_group_ptr_ptr =l add %new_group_start, 8
    %new_group_len_ptr =l add %new_group_start, 16
    %new_group_cap_ptr =l add %new_group_start, 24

    storew 1, %new_group_start
    storew %group_kind, %new_group_kind_ptr
    storel %new_group_ptr, %new_group_ptr_ptr
    storel %new_group_len, %new_group_len_ptr
    storel %new_group_len, %new_group_cap_ptr

    %current_len =l add %checkpoint, 1
    storel %current_len, %current_len_ptr
    ret 1
}

data $items_group_name = { b "items", b 0 }
data $items_group_name_len = { l 5 }

data $_brackets_group_name = { b "_brackets", b 0 }
data $_brackets_group_name_len = { l 9 }

data $root_group_name = { b "root", b 0 }
data $root_group_name_len = { l 4 }

data $unmatched_group_name = { b "unmatched", b 0 }
data $unmatched_group_name_len = { l 9 }

data $err_group_name = { b "group_error", b 0}


export function :str_slice $group_name(w %kind) {
@items
    %ptr =l copy $items_group_name
    %len =l copy 5
    %res =w ceqw %kind, 0
    jnz %res, @found, @_brackets

@_brackets
    %ptr =l copy $_brackets_group_name
    %len =l copy 9
    %res =w ceqw %kind, 1
    jnz %res, @found, @root

@root
    %ptr =l copy $root_group_name
    %len =l copy 4
    %res =w ceqw %kind, 2
    jnz %res, @found, @unmatched

@unmatched
    %ptr =l copy $unmatched_group_name
    %len =l copy 9
    %res =w ceqw %kind, 3
    jnz %res, @found, @err

@err
    %ptr =l copy $err_group_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}
data $err_label_name = { b "label_error", b 0}


export function :str_slice $label_name(w %kind) {
@err
    %ptr =l copy $err_label_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}
# RegexRange
function w $lex_2(l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %is_eof =w ceql %offset, %len
    jnz %is_eof, @fail, @cmp
@cmp
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_1 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_2(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_3 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_1(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_1(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_0 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_3(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_num (l %lexer_state) {
@start
    %res =w call $lex_0(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}


function w $lex_5 (l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %space =w ceqw %current, 32
    %lower =w cugew %current, 9
    %upper =w culew %current, 13
    %res =w and %lower, %upper
    %res =w or %res, %space
    jnz %res, @pass, @fail
@fail
    ret 0
@pass
    call $inc_offset(l %lexer_state)
    ret 1
}

# Rep0Regex
function w $lex_6 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_5(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_5(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_4 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_6(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_whitespace (l %lexer_state) {
@start
    %res =w call $lex_4(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_8 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 44)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_7 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_8(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_comma (l %lexer_state) {
@start
    %res =w call $lex_7(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_10 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 91)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_9 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_10(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_l_bracket (l %lexer_state) {
@start
    %res =w call $lex_9(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_12 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 93)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_11 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_12(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_r_bracket (l %lexer_state) {
@start
    %res =w call $lex_11(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

export function :vec $lex(l %ptr, l %len) {
@start
    %lexer_state =l alloc8 32

    %len_ptr =l add %lexer_state, 8
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %tokens =:vec call $new_vec(l 24)
    %last_was_error =w copy 0
    %total_offset =l copy 0
    jmp @loop
@loop
    jnz %len, @check_num, @end

@check_num
    storel 0, %group_end_ptr
    %res =l call $lex_num(l %lexer_state)
    jnz %res, @check_overflow_num, @check_whitespace
@check_overflow_num
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_num
@bump_num
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 0, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_whitespace
    storel 0, %group_end_ptr
    %res =l call $lex_whitespace(l %lexer_state)
    jnz %res, @check_overflow_whitespace, @check_comma
@check_overflow_whitespace
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_whitespace
@bump_whitespace
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 1, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_comma
    storel 0, %group_end_ptr
    %res =l call $lex_comma(l %lexer_state)
    jnz %res, @check_overflow_comma, @check_l_bracket
@check_overflow_comma
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_comma
@bump_comma
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 2, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_l_bracket
    storel 0, %group_end_ptr
    %res =l call $lex_l_bracket(l %lexer_state)
    jnz %res, @check_overflow_l_bracket, @check_r_bracket
@check_overflow_l_bracket
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_l_bracket
@bump_l_bracket
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 3, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@check_r_bracket
    storel 0, %group_end_ptr
    %res =l call $lex_r_bracket(l %lexer_state)
    jnz %res, @check_overflow_r_bracket, @fail
@check_overflow_r_bracket
    %overflow =l cugtl %res, %len
    jnz %overflow, @end, @bump_r_bracket
@bump_r_bracket
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 4, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    jmp @finish_loop


@finish_loop
    %ptr =l add %ptr, %res
    %len =l sub %len, %res
    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop
@fail
    jnz %last_was_error, @fail_again, @fail_first
@fail_first
    %end =l add %total_offset, 1
    %tok =:token call $new_token(l 5, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    jmp @fail_finish
@fail_again
    %end =l add %total_offset, 1
    %last_ptr =l call $last(l %tokens, l 24)
    %last_end_ptr =l add %last_ptr, 16
    %last_end =l loadl %last_end_ptr
    %new_end =l add %last_end, 1
    storel %new_end, %last_end_ptr
    jmp @fail_finish

@fail_finish
    %total_offset =l copy %end
    %ptr =l add %ptr, 1
    %len =l sub %len, 1
    storel 0, %offset_ptr
    storel 0, %group_end_ptr
    %last_was_error =w copy 1
    jmp @loop
    
@end
    ret %tokens
}

data $num_token_name = { b "num", b 0 }
data $num_token_name_len = { l 3 }

data $whitespace_token_name = { b "whitespace", b 0 }
data $whitespace_token_name_len = { l 10 }

data $comma_token_name = { b "comma", b 0 }
data $comma_token_name_len = { l 5 }

data $l_bracket_token_name = { b "l_bracket", b 0 }
data $l_bracket_token_name_len = { l 9 }

data $r_bracket_token_name = { b "r_bracket", b 0 }
data $r_bracket_token_name_len = { l 9 }

data $err_token_name = { b "token_error", b 0}


export function :str_slice $token_name(w %kind) {
@num
    %ptr =l copy $num_token_name
    %len =l copy 3
    %res =w ceqw %kind, 0
    jnz %res, @found, @whitespace

@whitespace
    %ptr =l copy $whitespace_token_name
    %len =l copy 10
    %res =w ceqw %kind, 1
    jnz %res, @found, @comma

@comma
    %ptr =l copy $comma_token_name
    %len =l copy 5
    %res =w ceqw %kind, 2
    jnz %res, @found, @l_bracket

@l_bracket
    %ptr =l copy $l_bracket_token_name
    %len =l copy 9
    %res =w ceqw %kind, 3
    jnz %res, @found, @r_bracket

@r_bracket
    %ptr =l copy $r_bracket_token_name
    %len =l copy 9
    %res =w ceqw %kind, 4
    jnz %res, @found, @err

@err
    %ptr =l copy $err_token_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}

# Parse Just
function l $parse_2(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_2(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_2_data = {l 0, l 3}

function :vec $expected_2() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_2_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_5(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 2
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_5(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_5_data = {l 0, l 2}

function :vec $expected_5() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_5_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 0
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_6(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_6_data = {l 0, l 0}

function :vec $expected_6() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_6_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function l $parse_4(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 6)
    %sep_index =l call $push_delim(l %state_ptr, l 5)
    %res =l call $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_5()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_6()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_5(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_4(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_4_data = {l 0, l 0}

function :vec $expected_4() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_4_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function l $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_4(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 0)
    %res =l call $parse_4(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_3(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_3_data = {l 1, l 0}

function :vec $expected_3() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_3_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function l $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 4
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump_skipped(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_7(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_7_data = {l 0, l 4}

function :vec $expected_7() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_7_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function l $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 7)
	call $push_long(l %delim_stack_ptr, l 3)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_2(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_2()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_2()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_3()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_3()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    %delim_start_index =l add %delim_stack_len, 3
    %invalid_delim =l cugel %res, %delim_start_index
    jnz %invalid_delim, @ret_no_break, @ret_res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_7()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_no_break
    ret 1
@ret_res
    ret %res
@ret_ok
    ret 0
}
function w $peak_1(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_1_data = {l 0, l 3}

function :vec $expected_1() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_1_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Skip
function l $parse_0(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %skipped =l call $skip(l %state_ptr, l 1)
    %res =l call $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %skipped, @unskip, @ret
@unskip
    call $unskip(l %state_ptr, l 1)
    ret %res
@ret
    ret %res
}
function w $peak_0(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_0_data = {l 0, l 3}

function :vec $expected_0() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_0_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

data $root_group_id = { w 2 }

export function w $parse(l %state_ptr) {
@start
    call $skip(l %state_ptr, l 1)

    jmp @loop
@loop
    %res =l call $parse_0(l %state_ptr, w 1, l 0)
    jnz %res, @check_eof, @end
@check_eof
    %is_eof =l ceql %res, 2
    jnz %is_eof, @missing, @bump_err
@missing
    %expected =:vec call $expected_0()
    call $missing(l %state_ptr, l %expected)
    jmp @end
@bump_err
    call $bump_err(l %state_ptr)
    jmp @loop
@end
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret, @expected_eof
@expected_eof
    call $bump_err(l %state_ptr)
    jmp @end
@ret
    ret 1
}

function l $peak_by_id(l %state_ptr, l %offset, w %recover, l %id) {

@check_0
    %res =l ceql %id, 0
    jnz %res, @do_0, @check_1
@do_0
    %ret =l call $peak_0(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_1
    %res =l ceql %id, 1
    jnz %res, @do_1, @check_2
@do_1
    %ret =l call $peak_1(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_2
    %res =l ceql %id, 2
    jnz %res, @do_2, @check_3
@do_2
    %ret =l call $peak_2(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_3
    %res =l ceql %id, 3
    jnz %res, @do_3, @check_4
@do_3
    %ret =l call $peak_3(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_4
    %res =l ceql %id, 4
    jnz %res, @do_4, @check_5
@do_4
    %ret =l call $peak_4(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_5
    %res =l ceql %id, 5
    jnz %res, @do_5, @check_6
@do_5
    %ret =l call $peak_5(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_6
    %res =l ceql %id, 6
    jnz %res, @do_6, @check_7
@do_6
    %ret =l call $peak_6(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_7
    %res =l ceql %id, 7
    jnz %res, @do_7, @err
@do_7
    %ret =l call $peak_7(l %state_ptr, l %offset, w %recover)
    ret %ret

@err
    ret 0
}
