type :str_slice = { l 2 }
type :vec = { l 3 }
type :token = { l 3 }

type :node = { w 2, l 3 }
type :lexer_state = { l 2, l 1, l 1}

data $match_just = { b "Matched just %d\n", b 0 }
data $eof_just = { b "Eof just %d\n", b 0 }
data $skipped_just = { b "Skipped just %d\n", b 0 }
data $break_just = { b "Break just %d\n", b 0 }
data $err_just = { b "Err just %d\n", b 0 }


# <stack: 3> <tokens: 3> <offset: 1> <delim_stack: 3> <skip: 3>
type :state = { l 3, l 3, l, l 3, l 3 }

export function :vec $test_vec_contains() {
@start
    %vec =:vec call $new_vec(l 8)
    call $push_long(l %vec, l 0)
    call $push_long(l %vec, l 1)
    call $push_long(l %vec, l 2)
    #%res =l call $contains_long(l %vec, l 1)
    ret %vec
}

function w $is_eof(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %tokens_len =l loadl %tokens_len_ptr

    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %res =w ceql %current, %tokens_len
    ret %res
}

data $skipping_token = { b "Skipping token %u\n", b 0 }

export function w $skip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @already, @push
@already
    ret 0
@push
    call $push_long(l %skip_ptr, l %token_kind)
    ret 1
}

export function w $unskip(l %state_ptr, l %token_kind) {
@start
    %skip_ptr =l add %state_ptr, 80
    %already =l call $contains_long(l %skip_ptr, l %token_kind)
    jnz %already, @remove, @already
@already
    ret 0
@remove
    %index =l sub %already, 1
    call $remove_long(l %skip_ptr, l %index)
    ret 1
}

function w $remove_long(l %vec, l %index) {
@start
    %len_ptr =l add %vec, 8
    %len     =l loadl %len_ptr
    %ptr     =l loadl %vec

    # bytes to move = (len - index - 1) * 8
    %len_minus_index =l sub %len, %index
    %len_minus_index =l sub %len_minus_index, 1
    %cpy_size =l mul %len_minus_index, 8

    # dst = ptr + index*8
    %offset  =l mul %index, 8
    %dst_ptr =l add %ptr, %offset

    # src = dst + 8
    %src_ptr =l add %dst_ptr, 8

    call $memcpy(l %dst_ptr, l %src_ptr, l %cpy_size)

    %len =l sub %len, 1
    storel %len, %len_ptr
    ret 1
}

data $checking_skipped = { b "Checking %u == %u\n" ,b 0}
data $found_skipped = { b "Found %d\n" ,b 0}
data $info_msg = {b "Checking contains long for arr %u, len: %u\n"}

function l $contains_long(l %vec, l %value) {
@start
    %ptr =l loadl %vec
    %len_ptr =l add %vec, 8
    %len =l loadl %len_ptr
    %index =l copy 0
    %item_ptr =l loadl %vec
    jnz %len, @loop, @false
@loop
    %item =l loadl %item_ptr
    %found =l ceql %item, %value
    jnz %found, @true, @iter
@iter
    %index =l add %index, 1
    %item_ptr =l add %item_ptr, 8
    %is_end =l ceql %index, %len
    jnz %is_end, @false, @loop
@false
    ret 0
@true
    %res =l add %index, 1
    ret %res
}

function l $push_delim(l %state_ptr, l %delim) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $push_long(l %delim_stack_ptr, l %delim)
    %delim_len_ptr =l add %delim_stack_ptr, 8
    %delim_len =l loadl %delim_len_ptr
    %res =l add 2, %delim_len
    ret %res
}

function w $pop_delim(l %state_ptr) {
@start
    %delim_stack_ptr =l add %state_ptr, 56
    call $pop(l %delim_stack_ptr, l 8)
    ret 1
}

export function w $bumpN(l %state_ptr, l %n) {
@start
    jmp @loop
@loop
    jnz %n, @iter, @ret
@iter
    %n =l sub %n, 1
    call $bump(l %state_ptr)
    jmp @loop
@ret
    ret 1
}

export function w $enter_group(l %state_ptr, w %group_kind) {
@start
    %stack_ptr =l add %state_ptr, 24
    %new =:node call $new_group_node(w %group_kind)
    call $push(l %stack_ptr, l 32, l %new)
    ret 1
}

function l $current_kind(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr
    %token_ptr =l call $get(l %state_ptr, l 24, l %current)
    %token =l loadl %token_ptr
    ret %token
}

export function l $kind_at_offset(l %state_ptr, l %offset) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %at_offset =l add %current, %offset
    %token_ptr =l call $get(l %state_ptr, l 24, l %at_offset)
    %token =l loadl %token_ptr
    ret %token
}

data $skipped_msg = { b "SKIPPED\n", b 0}
function l $after_skipped(l %state_ptr) {
@start
    %tokens_len_ptr =l add %state_ptr, 8
    %current_ptr =l add %state_ptr, 48

    %current =l loadl %current_ptr
    %len =l loadl %tokens_len_ptr

    %offset =l copy 0
    %skip_ptr =l add %state_ptr, 80
@check_eof
    %index =l add %offset, %current
    %is_eof =l ceql %len, %index
    jnz %is_eof, @ret, @loop
@loop
    %kind =l call $kind_at_offset(l %state_ptr, l %offset)
    %is_skipped =l call $contains_long(l %skip_ptr, l %kind)
    jnz %is_skipped, @iter, @ret
@iter
    %offset =l add %offset, 1
    jmp @check_eof
@ret
    ret %offset
}

export function w $exit_group(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24

    %removed =l call $pop(l %stack_ptr, l 32)
    %last =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %last, 8

    call $push(l %children_ptr, l 32, l %removed)
    ret 1
}

export function w $bump(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)
    %start_ptr =l add %tok_ptr, 8
    %end_ptr =l add %tok_ptr, 16


    %current =l add %current, 1
    storel %current, %current_ptr

    %token =l loadl %tok_ptr
    %start =l loadl %start_ptr
    %end =l loadl %end_ptr

    %new =:node call $new_token_node(l %token, l %start, l %end)

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8

    call $push(l %children_ptr, l 32, l %new)

    ret 1
}

export function w $missing(l %state_ptr, l %expected) {
@check_zero_expected
    %ptr =l loadl %expected
    jnz %ptr, @start, @ret
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %children_ptr =l add %current_group, 8
    %missing =:node call $new_missing_node(l %expected)
    call $push(l %children_ptr, l 32, l %missing)
    ret 1
@ret
    ret 1
}

export function w $bump_err(l %state_ptr) {
@start
    %current_ptr =l add %state_ptr, 48
    %current =l loadl %current_ptr

    %tok_ptr =l call $get(l %state_ptr, l 24, l %current)

    %current =l add %current, 1
    storel %current, %current_ptr

    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %children_ptr =l add %current_group, 8
    %last_child =l call $last(l %children_ptr, l 32)

    %last_child_kind =l loadl %last_child
    %last_is_err =l ceql %last_child_kind, 2
    jnz %last_is_err, @extend_err, @new_error
@extend_err
    %tokens =l add %last_child, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    ret 1
@new_error
    %new_node =:node call $new_error_node()
    %tokens =l add %new_node, 8
    call $push(l %tokens, l 24, l %tok_ptr)
    call $push(l %children_ptr, l 32, l %new_node)
    ret 1
}

export function l $default_state_ptr(l %ptr, l %len) {
@start
    %ptr =:state call $default_state(l %ptr, l %len)
    %res =l call $malloc(l 104)
    call $memcpy(l %res, l %ptr, l 104)
    ret %res
}

export function :state $get_state(l %ptr) {
@start
    %state =l alloc8 104
    blit %ptr, %state, 104
    ret %state
}

export function l $last(l %vec_ptr, l %size) {
@start
    %ptr =l loadl %vec_ptr

    %len_ptr =l add %vec_ptr, 8
    %len =l loadl %len_ptr

    %index =l sub %len, 1

    %offset =l mul %index, %size
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

export function :state $default_state(l %ptr, l %len) {
@start
    %tokens =:vec call $lex(l %ptr, l %len)
    %res =:state call $new_state(:vec %tokens)
    ret %res
}

function :state $new_state(:vec %tokens) {
@start
    %res =l alloc8 104
    %stack_ptr =l add %res, 24
    %offset_ptr =l add %res, 48
    %delim_stack_ptr =l add %res, 56
    %skip_ptr =l add %res, 80

    %root =w loadw $root_group_id
    %group =:node call $new_group_node(w %root)

    %stack =:vec call $new_vec(l 32)
    call $push(l %stack, l 32, l %group)

    %delim_stack =:vec call $new_vec(l 8)
    %skip =:vec call $new_vec(l 8)

    blit %tokens, %res, 24
    blit %stack, %stack_ptr, 24
    blit %delim_stack, %delim_stack_ptr, 24
    blit %skip, %skip_ptr, 24
    storel 0, %offset_ptr

    ret %res
}

data $debug_group = { b "Group { kind: %d, group_kind: %d, ptr: %d, len: %d, cap: %d, }", b 0 }

function w $print_group(:node %group) {
@start
    %group_kind_ptr =l add %group, 4
    %ptr_ptr =l add %group, 8
    %len_ptr =l add %group, 16
    %cap_ptr =l add %group, 24

    %kind =l loadw %group
    %group_kind =l loadw %group_kind_ptr
    %ptr =l loadl %ptr_ptr
    %len =l loadl %len_ptr
    %cap =l loadl %cap_ptr
    ret 1
}

export function l $get(l %vec_ptr, l %size, l %index) {
@start
    %ptr =l loadl %vec_ptr
    %offset =l mul %size, %index
    %item_ptr =l add %ptr, %offset
    ret %item_ptr
}

data $AHH = { b "AHHH", b 0 }
export function :node $new_token_node(l %kind, l %start, l %end) {
@start
    %res =l alloc8 32
    %kind_ptr =l add %res, 8
    %start_ptr =l add %res, 16
    %end_ptr =l add %res, 24
    storel 0, %res
    storel %kind, %kind_ptr
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function :node $new_missing_node(l %expected) {
@start
    %res =l alloc8 32
    %expected_ptr =l add 8, %res
    blit %expected, %expected_ptr, 24
    storew 3, %res
    ret %res
}

export function :node $new_group_node(w %kind) {
@start
    %res =l alloc8 32
    %group_kind =l add %res, 4
    %vec =:vec call $new_vec(l 32)
    %vec_ptr =l add %res, 8
    %group_kind_ptr =l add 4, %res
    blit %vec, %vec_ptr, 24
    storew 1, %res
    storew %kind, %group_kind_ptr
    ret %res
}



export function :node $new_error_node() {
@start
    %res =l alloc8 32
    %vec =:vec call $new_vec(l 24)
    %vec_ptr =l add %res, 8
    blit %vec, %vec_ptr, 24
    storel 2, %res
    ret %res
}

export function :vec $new_vec(l %item_size) {
@start
    %ptr_ptr =l alloc8 24
    %len_ptr =l add %ptr_ptr, 8
    %cap_ptr =l add %ptr_ptr, 16

    %size =l mul %item_size, 4
    %ptr =l call $malloc(l %size)

    storel %ptr, %ptr_ptr
    storel 0, %len_ptr
    storel 4, %cap_ptr
    ret %ptr_ptr
}


export function :token $new_token(l %kind, l %start, l %end) {
@start
    %res =l alloc8 24
    %start_ptr =l add %res, 8
    %end_ptr =l add %res, 16
    storel %kind, %res
    storel %start, %start_ptr
    storel %end, %end_ptr
    ret %res
}

export function l $pop(l %vec, l %value_size) {
@start
  %len_ptr =l add %vec, 8

  %ptr =l loadl %vec
  %len =l loadl %len_ptr

  %len =l sub %len, 1
  storel %len, %len_ptr

  %offset =l mul %len, %value_size
  %item_ptr =l add %offset, %ptr
  ret %item_ptr
}

export function w $push_long(l %vec, l %value) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %bytes =l mul %cap, 8
    %new_ptr =l call $malloc(l %bytes)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %bytes =l mul %len, 8
    call $memcpy(l %new_ptr, l %ptr, l %bytes)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
@push
    %offset =l mul %len, 8
    %item_ptr =l add %ptr, %offset
    %len =l add %len, 1
    storel %len, %len_ptr
    storel %value, %item_ptr
    ret 1
}

export function w $push(l %vec, l %value_size, l %value_ptr) {
@start
  %len_ptr =l add %vec, 8
  %cap_ptr =l add %vec, 16

  %ptr =l loadl %vec
  %len =l loadl %len_ptr
  %cap =l loadl %cap_ptr

  %full =w ceql %len, %cap
  jnz %full, @alloc, @push
@alloc
    %cap =l mul %cap, 4
    %size =l mul %cap, %value_size
    %new_ptr =l call $malloc(l %size)
    storel %cap, %cap_ptr
    storel %new_ptr, %vec

    %size =l mul %len, %value_size
    call $memcpy(l %new_ptr, l %ptr, l %size)
    call $free(l %ptr)
    %ptr =l copy %new_ptr
    jmp @push
@push
    %offset =l mul %len, %value_size
    %item_ptr =l add %offset, %ptr
    %len =l add %len, 1
    storel %len, %len_ptr
    call $memcpy(l %item_ptr, l %value_ptr, l %value_size)
    ret 1
}

export function w $free_node(l %n) {
@start
    %kind =w loadw %n
    %is0 =w ceqw %kind, 0
    jnz %is0, @case0, @check1
@check1
    # ---- check kind == 1 ----
    %is1 =w ceqw %kind, 1
    jnz %is1, @case1, @check2
@check2
    # ---- check kind == 2 ----
    %is2 =w ceqw %kind, 2
    jnz %is2, @case2, @check3

@check3
    # ---- check kind == 3 ----
    %is3 =w ceqw %kind, 3
    jnz %is3, @case3, @end


@case0
    jmp @end


@case1
    %childptr_ptr =l add %n, 8
    %childptr =l loadl %childptr_ptr
    %len_ptr =l add %n, 16
    %len =l loadl %len_ptr
    %i =l copy 0
    jmp @loop
@loop
    %cmp =w cultl %i, %len
    jnz %cmp, @loop_body, @loop_done
@loop_body
    %off   =l mul %i, 32
    %child =l add %childptr, %off
    call $free_node(l %child)
    %i =l add %i, 1
    jmp @loop

@loop_done
    call $free(l %childptr)
    jmp @end


@case2
    %tokptr_ptr =l add %n, 8
    %tokptr =l loadl %tokptr_ptr
    call $free(l %tokptr)
    jmp @end


@case3
    %exptr_ptr =l add %n, 8
    %exptr =l loadl %exptr_ptr
    call $free(l %exptr)
    jmp @end


@end
    ret 1
}

export function w $free_state(l %s) {
@start
    # ---- free tokens RawVec<Lexeme> ----
    # tokens.ptr at offset 0
    %tokptr_ptr =l add %s, 0
    %tokptr     =l loadl %tokptr_ptr
    call $free(l %tokptr)

    # ---- free stack RawVec<NodeData> (recursively with free_node) ----
    # stack.ptr at offset 24
    %stackptr_ptr =l add %s, 24
    %stackptr     =l loadl %stackptr_ptr

    # stack.len at offset 32
    %stacklen_ptr =l add %s, 32
    %stacklen     =l loadl %stacklen_ptr

    # i = 0
    %i =l copy 0
    jmp @stack_loop

@stack_loop
    # while (i < stacklen)
    %cmp =w cultl %i, %stacklen
    jnz %cmp, @stack_loop_body, @stack_loop_done

@stack_loop_body
    # node_i = stackptr + i * 32  (sizeof(NodeData) == 32)
    %off  =l mul %i, 32
    %node =l add %stackptr, %off

    # recursively free this node
    call $free_node(l %node)

    # i++
    %i =l add %i, 1
    jmp @stack_loop

@stack_loop_done
    # free(stack.ptr)
    call $free(l %stackptr)

    # ---- free delim_stack RawVec<usize> ----
    # delim_stack.ptr at offset 56
    %delimptr_ptr =l add %s, 56
    %delimptr     =l loadl %delimptr_ptr
    call $free(l %delimptr)

    # ---- free skip RawVec<usize> ----
    # skip.ptr at offset 80
    %skipptr_ptr =l add %s, 80
    %skipptr     =l loadl %skipptr_ptr
    call $free(l %skipptr)

    # done (StateData itself is not freed here)
    ret 1
}

function w $cmp_current(l %lexer_state, w %char) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %actual_offset =l add %ptr, %offset
    %current =w loadub %actual_offset
    %res =w ceqw %current, %char
    ret %res
}

function w $inc_offset(l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %offset =l add %offset, 1
    storel %offset, %offset_ptr
    ret 0
}

function w $checkpoint(l %state_ptr) {
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)
    %current_len_ptr =l add %current_group, 16
    %len =l loadl %current_len_ptr
    ret %len
}

function w $group_at(l %state_ptr, w %group_kind, l %checkpoint) {
@start
    %stack_ptr =l add %state_ptr, 24
    %current_group =l call $last(l %stack_ptr, l 32)

    %current_len_ptr =l add %current_group, 16
    %current_len =l loadl %current_len_ptr
    %current_ptr_ptr =l add %current_group, 8
    %current_ptr =l loadl %current_ptr_ptr

    %new_group_len =l sub %current_len, %checkpoint
    %new_group_start =l mul %checkpoint, 32
    %new_group_start =l add %new_group_start, %current_ptr
    %new_group_size =l mul %new_group_len, 32

    %new_group_ptr =l call $malloc(l %new_group_size)
    call $memcpy(l %new_group_ptr, l %new_group_start, l %new_group_size)

    %new_group_kind_ptr =l add %new_group_start, 4
    %new_group_ptr_ptr =l add %new_group_start, 8
    %new_group_len_ptr =l add %new_group_start, 16
    %new_group_cap_ptr =l add %new_group_start, 24

    storew 1, %new_group_start
    storew %group_kind, %new_group_kind_ptr
    storel %new_group_ptr, %new_group_ptr_ptr
    storel %new_group_len, %new_group_len_ptr
    storel %new_group_len, %new_group_cap_ptr

    %current_len =l add %checkpoint, 1
    storel %current_len, %current_len_ptr
    ret 1
}

# Exact
function l $lex_2 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 115)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 108)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 99)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_1 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_2(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_4(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_5(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_6(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_7(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_3 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_4(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_5(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_6(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_7(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_0 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_1(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_3(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_select (l %lexer_state) {
@start
    %res =w call $lex_0(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_10 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 102)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 114)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 111)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 109)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_9 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_10(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_12(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_13(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_14(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_15(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_11 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_12(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_13(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_14(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_15(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_8 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_9(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_11(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_from (l %lexer_state) {
@start
    %res =w call $lex_8(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_18 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 100)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 108)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_17 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_18(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_20(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_21(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_22(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_23(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_19 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_20(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_21(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_22(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_23(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_16 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_17(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_19(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_delete (l %lexer_state) {
@start
    %res =w call $lex_16(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_26 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 100)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 102)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 105)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 110)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_25 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_26(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_28(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_29(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_30(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_31(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_27 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_28(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_29(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_30(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_31(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_24 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_25(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_27(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_define (l %lexer_state) {
@start
    %res =w call $lex_24(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_34 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 97)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 98)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 108)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_33 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_34(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_36(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_37(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_38(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_39(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_35 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_36(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_37(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_38(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_39(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_32 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_33(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_35(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_table (l %lexer_state) {
@start
    %res =w call $lex_32(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_42 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 102)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 105)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 108)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 100)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_41 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_42(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_44(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_45(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_46(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_47(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_43 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_44(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_45(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_46(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_47(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_40 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_41(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_43(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_field (l %lexer_state) {
@start
    %res =w call $lex_40(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_50 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 111)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 110)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_49 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_50(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_52(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_53(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_54(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_55(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_51 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_52(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_53(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_54(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_55(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_48 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_49(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_51(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_on (l %lexer_state) {
@start
    %res =w call $lex_48(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_58 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 115)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 114)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 117)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_4, @fail

@part_4
    %res =w call $cmp_current(l %lexer_state, w 99)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_5, @fail

@part_5
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_57 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_58(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_60(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_61(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_62(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_63(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_59 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_60(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_61(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_62(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_63(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_56 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_57(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_59(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_struct (l %lexer_state) {
@start
    %res =w call $lex_56(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_66 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 110)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 117)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 109)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_65 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_66(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_68(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_69(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_70(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_71(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_67 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_68(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_69(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_70(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_71(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_64 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_65(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_67(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_enum (l %lexer_state) {
@start
    %res =w call $lex_64(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_74 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 118)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 111)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 105)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 100)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_73 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_74(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_76(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_77(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_78(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_79(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_75 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_76(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_77(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_78(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_79(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_72 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_73(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_75(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_void (l %lexer_state) {
@start
    %res =w call $lex_72(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_82 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 116)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $cmp_current(l %lexer_state, w 121)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $cmp_current(l %lexer_state, w 112)
    call $inc_offset(l %lexer_state)
    jnz %res, @part_3, @fail

@part_3
    %res =w call $cmp_current(l %lexer_state, w 101)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexGroup
function l $lex_81 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_82(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    %offset =l loadl %offset_ptr

    storel %offset, %group_end_ptr

    ret 1
@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexRange
function w $lex_84(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_85(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_86(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChar
function w $lex_87(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_83 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_84(l %lexer_state)
    jnz %res, @fail, @option_1

@option_1
    %res =w call $lex_85(l %lexer_state)
    jnz %res, @fail, @option_2

@option_2
    %res =w call $lex_86(l %lexer_state)
    jnz %res, @fail, @option_3

@option_3
    %res =w call $lex_87(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_80 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_81(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_83(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_type (l %lexer_state) {
@start
    %res =w call $lex_80(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# RegexRange
function w $lex_90(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 48
    %upper =w culew %current, 57
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_89 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_90(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_91 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_89(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_89(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_88 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_91(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_NUM (l %lexer_state) {
@start
    %res =w call $lex_88(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_93 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 34)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexChar
function w $lex_95(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 34)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexNegatedChoice
function l $lex_94 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @option_0

@option_0
    %res =w call $lex_95(l %lexer_state)
    jnz %res, @fail, @pass

@pass
    %offset =l loadl %offset_ptr
    %is_eof =l ceql %offset, %len
    jnz %is_eof, @eof, @inc
@inc
    call $inc_offset(l %lexer_state)
    ret 1
@eof
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_96 (l %lexer_state) {
@start
    jmp @loop
@check_eof
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_94(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
}

# Exact
function l $lex_97 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 34)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_92 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_93(l %lexer_state)
    jnz %res, @part_1, @fail

@part_1
    %res =w call $lex_96(l %lexer_state)
    jnz %res, @part_2, @fail

@part_2
    %res =w call $lex_97(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_STR (l %lexer_state) {
@start
    %res =w call $lex_92(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}


function w $lex_99 (l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %space =w ceqw %current, 32
    %lower =w cugew %current, 9
    %upper =w culew %current, 13
    %res =w and %lower, %upper
    %res =w or %res, %space
    jnz %res, @pass, @fail
@fail
    ret 0
@pass
    call $inc_offset(l %lexer_state)
    ret 1
}

# Rep0Regex
function w $lex_100 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_99(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_99(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_98 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_100(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_WHITESPACE (l %lexer_state) {
@start
    %res =w call $lex_98(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# RegexChar
function w $lex_103(l %lexer_state) {
@start
    %res =w call $cmp_current(l %lexer_state, w 95)
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_104(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 97
    %upper =w culew %current, 122
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexRange
function w $lex_105(l %lexer_state) {
@start
    %ptr =l loadl %lexer_state
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %index =l add %offset, %ptr
    %current =w loadub %index
    %lower =w cugew %current, 65
    %upper =w culew %current, 90
    %res =w and %lower, %upper
    jnz %res, @pass, @fail
@pass
    call $inc_offset(l %lexer_state)
    ret 1
@fail
    ret 0
}

# RegexChoice
function l $lex_102 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    storel %start, %offset_ptr
    %res =w call $lex_103(l %lexer_state)
    jnz %res, @pass, @part_1

@part_1
    storel %start, %offset_ptr
    %res =w call $lex_104(l %lexer_state)
    jnz %res, @pass, @part_2

@part_2
    storel %start, %offset_ptr
    %res =w call $lex_105(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# Rep0Regex
function w $lex_106 (l %lexer_state) {
@start
    %len_ptr =l add %lexer_state, 8
    %len =l loadl %len_ptr
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @fail, @check_start
@check_start
    %res =w call $lex_102(l %lexer_state)
    jnz %res, @check_eof, @fail
@check_eof
    %offset =l loadl %offset_ptr
    %eof =w ceql %offset, %len
    jnz %eof, @pass, @loop
@loop
    %res =w call $lex_102(l %lexer_state)
    jnz %res, @check_eof, @pass
@pass
    ret 1
@fail
    ret 0
}

# RegexSeq
function l $lex_101 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_106(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_IDENT (l %lexer_state) {
@start
    %res =w call $lex_101(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_108 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 58)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_107 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_108(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_COLON (l %lexer_state) {
@start
    %res =w call $lex_107(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_110 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 44)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_109 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_110(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_COMMA (l %lexer_state) {
@start
    %res =w call $lex_109(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_112 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 59)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_111 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_112(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_SEMI (l %lexer_state) {
@start
    %res =w call $lex_111(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_114 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 43)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_113 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_114(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_PLUS (l %lexer_state) {
@start
    %res =w call $lex_113(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_116 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 42)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_115 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_116(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_TIMES (l %lexer_state) {
@start
    %res =w call $lex_115(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_118 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 40)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_117 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_118(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_LParen (l %lexer_state) {
@start
    %res =w call $lex_117(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

# Exact
function l $lex_120 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $cmp_current(l %lexer_state, w 41)
    call $inc_offset(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

# RegexSeq
function l $lex_119 (l %lexer_state) {
@start
    %offset_ptr =l add %lexer_state, 16
    %start =l loadl %offset_ptr
    jmp @part_0

@part_0
    %res =w call $lex_120(l %lexer_state)
    jnz %res, @pass, @fail

@pass
    ret 1

@fail
    storel %start, %offset_ptr
    ret 0
}

function l $lex_RParen (l %lexer_state) {
@start
    %res =w call $lex_119(l %lexer_state)
    jnz %res, @pass, @fail
@pass
    %group_ptr =l add %lexer_state, 24
    %group =l loadl %group_ptr
    jnz %group, @ret_group, @ret_all
@ret_group
    ret %group
@ret_all
    %offset_ptr =l add %lexer_state, 16
    %offset =l loadl %offset_ptr
    ret %offset
@fail
    ret 0
}

export function :vec $lex(l %ptr, l %len) {
@start
    %lexer_state =l alloc8 32

    %len_ptr =l add %lexer_state, 8
    %offset_ptr =l add %lexer_state, 16
    %group_end_ptr =l add %lexer_state, 24

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %tokens =:vec call $new_vec(l 24)
    %last_was_error =w copy 0
    %total_offset =l copy 0
    jmp @loop
@loop
    jnz %len, @check_select, @end

@check_select
    storel 0, %group_end_ptr
    %res =l call $lex_select(l %lexer_state)
    jnz %res, @bump_select, @check_from
@bump_select
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 0, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_from
    storel 0, %group_end_ptr
    %res =l call $lex_from(l %lexer_state)
    jnz %res, @bump_from, @check_delete
@bump_from
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 1, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_delete
    storel 0, %group_end_ptr
    %res =l call $lex_delete(l %lexer_state)
    jnz %res, @bump_delete, @check_define
@bump_delete
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 2, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_define
    storel 0, %group_end_ptr
    %res =l call $lex_define(l %lexer_state)
    jnz %res, @bump_define, @check_table
@bump_define
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 3, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_table
    storel 0, %group_end_ptr
    %res =l call $lex_table(l %lexer_state)
    jnz %res, @bump_table, @check_field
@bump_table
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 4, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_field
    storel 0, %group_end_ptr
    %res =l call $lex_field(l %lexer_state)
    jnz %res, @bump_field, @check_on
@bump_field
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 5, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_on
    storel 0, %group_end_ptr
    %res =l call $lex_on(l %lexer_state)
    jnz %res, @bump_on, @check_struct
@bump_on
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 6, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_struct
    storel 0, %group_end_ptr
    %res =l call $lex_struct(l %lexer_state)
    jnz %res, @bump_struct, @check_enum
@bump_struct
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 7, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_enum
    storel 0, %group_end_ptr
    %res =l call $lex_enum(l %lexer_state)
    jnz %res, @bump_enum, @check_void
@bump_enum
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 8, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_void
    storel 0, %group_end_ptr
    %res =l call $lex_void(l %lexer_state)
    jnz %res, @bump_void, @check_type
@bump_void
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 9, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_type
    storel 0, %group_end_ptr
    %res =l call $lex_type(l %lexer_state)
    jnz %res, @bump_type, @check_NUM
@bump_type
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 10, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_NUM
    storel 0, %group_end_ptr
    %res =l call $lex_NUM(l %lexer_state)
    jnz %res, @bump_NUM, @check_STR
@bump_NUM
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 11, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_STR
    storel 0, %group_end_ptr
    %res =l call $lex_STR(l %lexer_state)
    jnz %res, @bump_STR, @check_WHITESPACE
@bump_STR
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 12, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_WHITESPACE
    storel 0, %group_end_ptr
    %res =l call $lex_WHITESPACE(l %lexer_state)
    jnz %res, @bump_WHITESPACE, @check_IDENT
@bump_WHITESPACE
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 13, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_IDENT
    storel 0, %group_end_ptr
    %res =l call $lex_IDENT(l %lexer_state)
    jnz %res, @bump_IDENT, @check_COLON
@bump_IDENT
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 14, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_COLON
    storel 0, %group_end_ptr
    %res =l call $lex_COLON(l %lexer_state)
    jnz %res, @bump_COLON, @check_COMMA
@bump_COLON
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 15, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_COMMA
    storel 0, %group_end_ptr
    %res =l call $lex_COMMA(l %lexer_state)
    jnz %res, @bump_COMMA, @check_SEMI
@bump_COMMA
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 16, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_SEMI
    storel 0, %group_end_ptr
    %res =l call $lex_SEMI(l %lexer_state)
    jnz %res, @bump_SEMI, @check_PLUS
@bump_SEMI
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 17, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_PLUS
    storel 0, %group_end_ptr
    %res =l call $lex_PLUS(l %lexer_state)
    jnz %res, @bump_PLUS, @check_TIMES
@bump_PLUS
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 18, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_TIMES
    storel 0, %group_end_ptr
    %res =l call $lex_TIMES(l %lexer_state)
    jnz %res, @bump_TIMES, @check_LParen
@bump_TIMES
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 19, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_LParen
    storel 0, %group_end_ptr
    %res =l call $lex_LParen(l %lexer_state)
    jnz %res, @bump_LParen, @check_RParen
@bump_LParen
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 20, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@check_RParen
    storel 0, %group_end_ptr
    %res =l call $lex_RParen(l %lexer_state)
    jnz %res, @bump_RParen, @fail
@bump_RParen
    %end =l add %total_offset, %res
    %tok =:token call $new_token(l 21, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    %total_offset =l copy %end
    %ptr =l add %ptr, %res
    %len =l sub %len, %res

    storel %ptr, %lexer_state
    storel %len, %len_ptr
    storel 0, %offset_ptr
    storel 0, %group_end_ptr

    %last_was_error =w copy 0
    jmp @loop

@fail
    jnz %last_was_error, @fail_again, @fail_first
@fail_first
    %end =l add %total_offset, 1
    %tok =:token call $new_token(l 22, l %total_offset, l %end)
    call $push(l %tokens, l 24, l %tok)
    jmp @fail_finish
@fail_again
    %end =l add %total_offset, 1
    %last_ptr =l call $last(l %tokens, l 24)
    %last_end_ptr =l add %last_ptr, 16
    %last_end =l loadl %last_end_ptr
    %new_end =l add %last_end, 1
    storel %new_end, %last_end_ptr
    jmp @fail_finish

@fail_finish
    %total_offset =l copy %end
    %ptr =l add %ptr, 1
    %len =l sub %len, 1
    storel 0, %offset_ptr
    storel 0, %group_end_ptr
    %last_was_error =w copy 1
    jmp @loop
    
@end
    ret %tokens
}

data $select_token_name = { b "select", b 0 }
data $select_token_name_len = { l 6 }

data $from_token_name = { b "from", b 0 }
data $from_token_name_len = { l 4 }

data $delete_token_name = { b "delete", b 0 }
data $delete_token_name_len = { l 6 }

data $define_token_name = { b "define", b 0 }
data $define_token_name_len = { l 6 }

data $table_token_name = { b "table", b 0 }
data $table_token_name_len = { l 5 }

data $field_token_name = { b "field", b 0 }
data $field_token_name_len = { l 5 }

data $on_token_name = { b "on", b 0 }
data $on_token_name_len = { l 2 }

data $struct_token_name = { b "struct", b 0 }
data $struct_token_name_len = { l 6 }

data $enum_token_name = { b "enum", b 0 }
data $enum_token_name_len = { l 4 }

data $void_token_name = { b "void", b 0 }
data $void_token_name_len = { l 4 }

data $type_token_name = { b "type", b 0 }
data $type_token_name_len = { l 4 }

data $NUM_token_name = { b "NUM", b 0 }
data $NUM_token_name_len = { l 3 }

data $STR_token_name = { b "STR", b 0 }
data $STR_token_name_len = { l 3 }

data $WHITESPACE_token_name = { b "WHITESPACE", b 0 }
data $WHITESPACE_token_name_len = { l 10 }

data $IDENT_token_name = { b "IDENT", b 0 }
data $IDENT_token_name_len = { l 5 }

data $COLON_token_name = { b "COLON", b 0 }
data $COLON_token_name_len = { l 5 }

data $COMMA_token_name = { b "COMMA", b 0 }
data $COMMA_token_name_len = { l 5 }

data $SEMI_token_name = { b "SEMI", b 0 }
data $SEMI_token_name_len = { l 4 }

data $PLUS_token_name = { b "PLUS", b 0 }
data $PLUS_token_name_len = { l 4 }

data $TIMES_token_name = { b "TIMES", b 0 }
data $TIMES_token_name_len = { l 5 }

data $LParen_token_name = { b "LParen", b 0 }
data $LParen_token_name_len = { l 6 }

data $RParen_token_name = { b "RParen", b 0 }
data $RParen_token_name_len = { l 6 }

data $err_token_name = { b "token_error", b 0}


export function :str_slice $token_name(w %kind) {
@select
    %ptr =l copy $select_token_name
    %len =l copy 6
    %res =w ceqw %kind, 0
    jnz %res, @found, @from

@from
    %ptr =l copy $from_token_name
    %len =l copy 4
    %res =w ceqw %kind, 1
    jnz %res, @found, @delete

@delete
    %ptr =l copy $delete_token_name
    %len =l copy 6
    %res =w ceqw %kind, 2
    jnz %res, @found, @define

@define
    %ptr =l copy $define_token_name
    %len =l copy 6
    %res =w ceqw %kind, 3
    jnz %res, @found, @table

@table
    %ptr =l copy $table_token_name
    %len =l copy 5
    %res =w ceqw %kind, 4
    jnz %res, @found, @field

@field
    %ptr =l copy $field_token_name
    %len =l copy 5
    %res =w ceqw %kind, 5
    jnz %res, @found, @on

@on
    %ptr =l copy $on_token_name
    %len =l copy 2
    %res =w ceqw %kind, 6
    jnz %res, @found, @struct

@struct
    %ptr =l copy $struct_token_name
    %len =l copy 6
    %res =w ceqw %kind, 7
    jnz %res, @found, @enum

@enum
    %ptr =l copy $enum_token_name
    %len =l copy 4
    %res =w ceqw %kind, 8
    jnz %res, @found, @void

@void
    %ptr =l copy $void_token_name
    %len =l copy 4
    %res =w ceqw %kind, 9
    jnz %res, @found, @type

@type
    %ptr =l copy $type_token_name
    %len =l copy 4
    %res =w ceqw %kind, 10
    jnz %res, @found, @NUM

@NUM
    %ptr =l copy $NUM_token_name
    %len =l copy 3
    %res =w ceqw %kind, 11
    jnz %res, @found, @STR

@STR
    %ptr =l copy $STR_token_name
    %len =l copy 3
    %res =w ceqw %kind, 12
    jnz %res, @found, @WHITESPACE

@WHITESPACE
    %ptr =l copy $WHITESPACE_token_name
    %len =l copy 10
    %res =w ceqw %kind, 13
    jnz %res, @found, @IDENT

@IDENT
    %ptr =l copy $IDENT_token_name
    %len =l copy 5
    %res =w ceqw %kind, 14
    jnz %res, @found, @COLON

@COLON
    %ptr =l copy $COLON_token_name
    %len =l copy 5
    %res =w ceqw %kind, 15
    jnz %res, @found, @COMMA

@COMMA
    %ptr =l copy $COMMA_token_name
    %len =l copy 5
    %res =w ceqw %kind, 16
    jnz %res, @found, @SEMI

@SEMI
    %ptr =l copy $SEMI_token_name
    %len =l copy 4
    %res =w ceqw %kind, 17
    jnz %res, @found, @PLUS

@PLUS
    %ptr =l copy $PLUS_token_name
    %len =l copy 4
    %res =w ceqw %kind, 18
    jnz %res, @found, @TIMES

@TIMES
    %ptr =l copy $TIMES_token_name
    %len =l copy 5
    %res =w ceqw %kind, 19
    jnz %res, @found, @LParen

@LParen
    %ptr =l copy $LParen_token_name
    %len =l copy 6
    %res =w ceqw %kind, 20
    jnz %res, @found, @RParen

@RParen
    %ptr =l copy $RParen_token_name
    %len =l copy 6
    %res =w ceqw %kind, 21
    jnz %res, @found, @err

@err
    %ptr =l copy $err_token_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}
function l $peak_by_id(l %state_ptr, l %offset, w %recover, l %id) {

@check_0
    %res =l ceql %id, 0
    jnz %res, @do_0, @check_1
@do_0
    %ret =l call $peak_0(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_1
    %res =l ceql %id, 1
    jnz %res, @do_1, @check_2
@do_1
    %ret =l call $peak_1(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_2
    %res =l ceql %id, 2
    jnz %res, @do_2, @check_3
@do_2
    %ret =l call $peak_2(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_3
    %res =l ceql %id, 3
    jnz %res, @do_3, @check_4
@do_3
    %ret =l call $peak_3(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_4
    %res =l ceql %id, 4
    jnz %res, @do_4, @check_5
@do_4
    %ret =l call $peak_4(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_5
    %res =l ceql %id, 5
    jnz %res, @do_5, @check_6
@do_5
    %ret =l call $peak_5(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_6
    %res =l ceql %id, 6
    jnz %res, @do_6, @check_7
@do_6
    %ret =l call $peak_6(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_7
    %res =l ceql %id, 7
    jnz %res, @do_7, @check_8
@do_7
    %ret =l call $peak_7(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_8
    %res =l ceql %id, 8
    jnz %res, @do_8, @check_9
@do_8
    %ret =l call $peak_8(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_9
    %res =l ceql %id, 9
    jnz %res, @do_9, @check_10
@do_9
    %ret =l call $peak_9(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_10
    %res =l ceql %id, 10
    jnz %res, @do_10, @check_11
@do_10
    %ret =l call $peak_10(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_11
    %res =l ceql %id, 11
    jnz %res, @do_11, @check_12
@do_11
    %ret =l call $peak_11(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_12
    %res =l ceql %id, 12
    jnz %res, @do_12, @check_13
@do_12
    %ret =l call $peak_12(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_13
    %res =l ceql %id, 13
    jnz %res, @do_13, @check_14
@do_13
    %ret =l call $peak_13(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_14
    %res =l ceql %id, 14
    jnz %res, @do_14, @check_15
@do_14
    %ret =l call $peak_14(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_15
    %res =l ceql %id, 15
    jnz %res, @do_15, @check_16
@do_15
    %ret =l call $peak_15(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_16
    %res =l ceql %id, 16
    jnz %res, @do_16, @check_17
@do_16
    %ret =l call $peak_16(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_17
    %res =l ceql %id, 17
    jnz %res, @do_17, @check_18
@do_17
    %ret =l call $peak_17(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_18
    %res =l ceql %id, 18
    jnz %res, @do_18, @check_19
@do_18
    %ret =l call $peak_18(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_19
    %res =l ceql %id, 19
    jnz %res, @do_19, @check_20
@do_19
    %ret =l call $peak_19(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_20
    %res =l ceql %id, 20
    jnz %res, @do_20, @check_21
@do_20
    %ret =l call $peak_20(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_21
    %res =l ceql %id, 21
    jnz %res, @do_21, @check_22
@do_21
    %ret =l call $peak_21(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_22
    %res =l ceql %id, 22
    jnz %res, @do_22, @check_23
@do_22
    %ret =l call $peak_22(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_23
    %res =l ceql %id, 23
    jnz %res, @do_23, @check_24
@do_23
    %ret =l call $peak_23(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_24
    %res =l ceql %id, 24
    jnz %res, @do_24, @check_25
@do_24
    %ret =l call $peak_24(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_25
    %res =l ceql %id, 25
    jnz %res, @do_25, @check_26
@do_25
    %ret =l call $peak_25(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_26
    %res =l ceql %id, 26
    jnz %res, @do_26, @check_27
@do_26
    %ret =l call $peak_26(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_27
    %res =l ceql %id, 27
    jnz %res, @do_27, @check_28
@do_27
    %ret =l call $peak_27(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_28
    %res =l ceql %id, 28
    jnz %res, @do_28, @check_29
@do_28
    %ret =l call $peak_28(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_29
    %res =l ceql %id, 29
    jnz %res, @do_29, @check_30
@do_29
    %ret =l call $peak_29(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_30
    %res =l ceql %id, 30
    jnz %res, @do_30, @check_31
@do_30
    %ret =l call $peak_30(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_31
    %res =l ceql %id, 31
    jnz %res, @do_31, @check_32
@do_31
    %ret =l call $peak_31(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_32
    %res =l ceql %id, 32
    jnz %res, @do_32, @check_33
@do_32
    %ret =l call $peak_32(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_33
    %res =l ceql %id, 33
    jnz %res, @do_33, @check_34
@do_33
    %ret =l call $peak_33(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_34
    %res =l ceql %id, 34
    jnz %res, @do_34, @check_35
@do_34
    %ret =l call $peak_34(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_35
    %res =l ceql %id, 35
    jnz %res, @do_35, @check_36
@do_35
    %ret =l call $peak_35(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_36
    %res =l ceql %id, 36
    jnz %res, @do_36, @check_37
@do_36
    %ret =l call $peak_36(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_37
    %res =l ceql %id, 37
    jnz %res, @do_37, @check_38
@do_37
    %ret =l call $peak_37(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_38
    %res =l ceql %id, 38
    jnz %res, @do_38, @check_39
@do_38
    %ret =l call $peak_38(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_39
    %res =l ceql %id, 39
    jnz %res, @do_39, @check_40
@do_39
    %ret =l call $peak_39(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_40
    %res =l ceql %id, 40
    jnz %res, @do_40, @check_41
@do_40
    %ret =l call $peak_40(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_41
    %res =l ceql %id, 41
    jnz %res, @do_41, @check_42
@do_41
    %ret =l call $peak_41(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_42
    %res =l ceql %id, 42
    jnz %res, @do_42, @check_43
@do_42
    %ret =l call $peak_42(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_43
    %res =l ceql %id, 43
    jnz %res, @do_43, @check_44
@do_43
    %ret =l call $peak_43(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_44
    %res =l ceql %id, 44
    jnz %res, @do_44, @check_45
@do_44
    %ret =l call $peak_44(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_45
    %res =l ceql %id, 45
    jnz %res, @do_45, @check_46
@do_45
    %ret =l call $peak_45(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_46
    %res =l ceql %id, 46
    jnz %res, @do_46, @check_47
@do_46
    %ret =l call $peak_46(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_47
    %res =l ceql %id, 47
    jnz %res, @do_47, @check_48
@do_47
    %ret =l call $peak_47(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_48
    %res =l ceql %id, 48
    jnz %res, @do_48, @check_49
@do_48
    %ret =l call $peak_48(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_49
    %res =l ceql %id, 49
    jnz %res, @do_49, @check_50
@do_49
    %ret =l call $peak_49(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_50
    %res =l ceql %id, 50
    jnz %res, @do_50, @check_51
@do_50
    %ret =l call $peak_50(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_51
    %res =l ceql %id, 51
    jnz %res, @do_51, @check_52
@do_51
    %ret =l call $peak_51(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_52
    %res =l ceql %id, 52
    jnz %res, @do_52, @check_53
@do_52
    %ret =l call $peak_52(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_53
    %res =l ceql %id, 53
    jnz %res, @do_53, @check_54
@do_53
    %ret =l call $peak_53(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_54
    %res =l ceql %id, 54
    jnz %res, @do_54, @check_55
@do_54
    %ret =l call $peak_54(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_55
    %res =l ceql %id, 55
    jnz %res, @do_55, @check_56
@do_55
    %ret =l call $peak_55(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_56
    %res =l ceql %id, 56
    jnz %res, @do_56, @check_57
@do_56
    %ret =l call $peak_56(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_57
    %res =l ceql %id, 57
    jnz %res, @do_57, @check_58
@do_57
    %ret =l call $peak_57(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_58
    %res =l ceql %id, 58
    jnz %res, @do_58, @check_59
@do_58
    %ret =l call $peak_58(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_59
    %res =l ceql %id, 59
    jnz %res, @do_59, @check_60
@do_59
    %ret =l call $peak_59(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_60
    %res =l ceql %id, 60
    jnz %res, @do_60, @check_61
@do_60
    %ret =l call $peak_60(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_61
    %res =l ceql %id, 61
    jnz %res, @do_61, @check_62
@do_61
    %ret =l call $peak_61(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_62
    %res =l ceql %id, 62
    jnz %res, @do_62, @check_63
@do_62
    %ret =l call $peak_62(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_63
    %res =l ceql %id, 63
    jnz %res, @do_63, @check_64
@do_63
    %ret =l call $peak_63(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_64
    %res =l ceql %id, 64
    jnz %res, @do_64, @check_65
@do_64
    %ret =l call $peak_64(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_65
    %res =l ceql %id, 65
    jnz %res, @do_65, @check_66
@do_65
    %ret =l call $peak_65(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_66
    %res =l ceql %id, 66
    jnz %res, @do_66, @check_67
@do_66
    %ret =l call $peak_66(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_67
    %res =l ceql %id, 67
    jnz %res, @do_67, @check_68
@do_67
    %ret =l call $peak_67(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_68
    %res =l ceql %id, 68
    jnz %res, @do_68, @check_69
@do_68
    %ret =l call $peak_68(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_69
    %res =l ceql %id, 69
    jnz %res, @do_69, @check_70
@do_69
    %ret =l call $peak_69(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_70
    %res =l ceql %id, 70
    jnz %res, @do_70, @check_71
@do_70
    %ret =l call $peak_70(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_71
    %res =l ceql %id, 71
    jnz %res, @do_71, @check_72
@do_71
    %ret =l call $peak_71(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_72
    %res =l ceql %id, 72
    jnz %res, @do_72, @check_73
@do_72
    %ret =l call $peak_72(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_73
    %res =l ceql %id, 73
    jnz %res, @do_73, @check_74
@do_73
    %ret =l call $peak_73(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_74
    %res =l ceql %id, 74
    jnz %res, @do_74, @check_75
@do_74
    %ret =l call $peak_74(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_75
    %res =l ceql %id, 75
    jnz %res, @do_75, @check_76
@do_75
    %ret =l call $peak_75(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_76
    %res =l ceql %id, 76
    jnz %res, @do_76, @check_77
@do_76
    %ret =l call $peak_76(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_77
    %res =l ceql %id, 77
    jnz %res, @do_77, @check_78
@do_77
    %ret =l call $peak_77(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_78
    %res =l ceql %id, 78
    jnz %res, @do_78, @check_79
@do_78
    %ret =l call $peak_78(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_79
    %res =l ceql %id, 79
    jnz %res, @do_79, @check_80
@do_79
    %ret =l call $peak_79(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_80
    %res =l ceql %id, 80
    jnz %res, @do_80, @check_81
@do_80
    %ret =l call $peak_80(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_81
    %res =l ceql %id, 81
    jnz %res, @do_81, @check_82
@do_81
    %ret =l call $peak_81(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_82
    %res =l ceql %id, 82
    jnz %res, @do_82, @check_83
@do_82
    %ret =l call $peak_82(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_83
    %res =l ceql %id, 83
    jnz %res, @do_83, @check_84
@do_83
    %ret =l call $peak_83(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_84
    %res =l ceql %id, 84
    jnz %res, @do_84, @check_85
@do_84
    %ret =l call $peak_84(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_85
    %res =l ceql %id, 85
    jnz %res, @do_85, @check_86
@do_85
    %ret =l call $peak_85(l %state_ptr, l %offset, w %recover)
    ret %ret

@check_86
    %res =l ceql %id, 86
    jnz %res, @do_86, @err
@do_86
    %ret =l call $peak_86(l %state_ptr, l %offset, w %recover)
    ret %ret

@err
    ret 0
}


# Parse Just
function w $parse_0(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_0(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_0_data = {l 0, l 14}

function :vec $expected_0() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_0_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_0(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 0)
    %res =l call $parse_0(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_1(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_1_data = {l 1, l 0}

function :vec $expected_1() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_1_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_2(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 11
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_2(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_2_data = {l 0, l 11}

function :vec $expected_2() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_2_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_2(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 1)
    %res =l call $parse_2(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_3(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_3_data = {l 1, l 1}

function :vec $expected_3() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_3_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_4(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 12
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_4(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_4_data = {l 0, l 12}

function :vec $expected_4() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_4_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_5(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_4(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 2)
    %res =l call $parse_4(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_5(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_5_data = {l 1, l 2}

function :vec $expected_5() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_5_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Fold
function w $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_13(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %res =l call $parse_13(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @parse_next
@parse_next
    %res =l call $parse_15(l %state_ptr, w %recover)
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 6, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_6(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_6_data = {l 1, l 0,l 1, l 1,l 1, l 2,l 0, l 20}

function :vec $expected_6() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_6_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 20
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_7(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_7_data = {l 0, l 20}

function :vec $expected_7() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_7_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_8(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 21
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_8(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 21
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_8_data = {l 0, l 21}

function :vec $expected_8() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_8_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Delim
function w $parse_9(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_7(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @add_delim
@add_delim
    %delim_index =l call $push_delim(l %state_ptr, l 8)
    jmp @try_parse_inner

@try_parse_inner
    %res =l call $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_inner, @check_missing_item
@bump_err_inner
    call $bump_err(l %state_ptr)
    jmp @try_parse_inner

@try_parse_close
    %res =l call $parse_8(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_close, @check_missing_close
@bump_err_close
    call $bump_err(l %state_ptr)
    jmp @try_parse_close

@check_missing_item
    jnz %res, @missing_item_err, @try_parse_close
@missing_item_err
    %expected =:vec call $expected_6()
    call $missing(l %state_ptr, l %expected)
    %hit_delim =l ceql %delim_index, %res
    jnz %hit_delim, @try_parse_close, @missing_close_err
@check_missing_close
    jnz %res, @missing_close_err, @ret_ok
@missing_close_err
    %expected =:vec call $expected_8()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_err
    ret %res
@ret_ok
    call $pop_delim(l %state_ptr)
    ret 0
}
function w $peak_9(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_9_data = {l 0, l 20}

function :vec $expected_9() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_9_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_10(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_3(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_5(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_9(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res

}
function w $peak_10(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_10_data = {l 1, l 0,l 1, l 1,l 1, l 2,l 0, l 20}

function :vec $expected_10() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_10_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_11(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 19
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_11(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_11_data = {l 0, l 19}

function :vec $expected_11() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_11_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_12(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 10)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_11(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_11()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_10(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_10()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_12(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 19
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_12_data = {l 0, l 19}

function :vec $expected_12() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_12_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Fold
function w $parse_13(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_10(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %res =l call $parse_10(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @parse_next
@parse_next
    %res =l call $parse_12(l %state_ptr, w %recover)
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 5, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_13(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_13_data = {l 1, l 0,l 1, l 1,l 1, l 2,l 0, l 20}

function :vec $expected_13() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_13_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_14(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 18
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_14(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_14_data = {l 0, l 18}

function :vec $expected_14() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_14_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_15(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 13)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_14(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_14()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_14()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_13(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_13()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_15(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 18
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_15_data = {l 0, l 18}

function :vec $expected_15() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_15_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Fold
function w $parse_16(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_13(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %res =l call $parse_13(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @parse_next
@parse_next
    %res =l call $parse_15(l %state_ptr, w %recover)
    jnz %res, @ret_ok, @create_group
@create_group
    call $group_at(l %state_ptr, w 6, l %checkpoint)
    ret 0
@ret_ok
    ret 0
@ret_err
    ret %res
@eof
    ret 2
}
function w $peak_16(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_16_data = {l 1, l 0,l 1, l 1,l 1, l 2,l 0, l 20}

function :vec $expected_16() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_16_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_17(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_17(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_17_data = {l 0, l 14}

function :vec $expected_17() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_17_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_17(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 7)
    %res =l call $parse_17(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_18(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_18_data = {l 1, l 7}

function :vec $expected_18() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_18_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 0
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_19(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_19_data = {l 0, l 0}

function :vec $expected_19() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_19_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_20(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 16
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_20(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 16
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_20_data = {l 0, l 16}

function :vec $expected_20() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_20_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function w $parse_21(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 6)
    %sep_index =l call $push_delim(l %state_ptr, l 20)
    %res =l call $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_20()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_6()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_20(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_6(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_21(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 12
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 11
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 20
    jnz %res, @ret_ok, @check_3
@check_3
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_21_data = {l 1, l 0,l 1, l 1,l 1, l 2,l 0, l 20}

function :vec $expected_21() {
@start
    %ptr =l call $malloc(l 64)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_21_data, l 64)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 4, %len_ptr
    storel 4, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_22(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 1
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_22(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_22_data = {l 0, l 1}

function :vec $expected_22() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_22_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_23(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 6
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 22)
	call $push_long(l %delim_stack_ptr, l 21)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_19(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_19()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_21(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_21()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_21()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_22(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_22()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @check_last
@missing_3
    %expected =:vec call $expected_22()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @check_last
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_23(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_23_data = {l 0, l 0}

function :vec $expected_23() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_23_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_23(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 8)
    %res =l call $parse_23(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_24(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_24_data = {l 1, l 8}

function :vec $expected_24() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_24_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 2
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_25(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_25_data = {l 0, l 2}

function :vec $expected_25() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_25_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_26(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 1
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_26(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 1
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_26_data = {l 0, l 1}

function :vec $expected_26() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_26_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_27(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 14
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_27(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 14
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_27_data = {l 0, l 14}

function :vec $expected_27() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_27_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_28(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 27)
	call $push_long(l %delim_stack_ptr, l 26)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_25(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_25()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_25()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_26(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_26()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_26()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_27(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_27()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_28(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_28_data = {l 0, l 2}

function :vec $expected_28() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_28_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_29(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_28(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 9)
    %res =l call $parse_28(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_29(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_29_data = {l 1, l 9}

function :vec $expected_29() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_29_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_30(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_30(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_30_data = {l 0, l 3}

function :vec $expected_30() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_30_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_31(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 4
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_31(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_31_data = {l 0, l 4}

function :vec $expected_31() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_31_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_32(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 17
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_32(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_32_data = {l 0, l 17}

function :vec $expected_32() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_32_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_33(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 6
	call $push_long(l %delim_stack_ptr, l 32)
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 31)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_30(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_30()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_30()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_31(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @check_last
@missing_3
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_32(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @check_last
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_32()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_33(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_33_data = {l 0, l 3}

function :vec $expected_33() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_33_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_34(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_33(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 10)
    %res =l call $parse_33(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_34(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_34_data = {l 1, l 10}

function :vec $expected_34() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_34_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_35(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_35(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_35_data = {l 0, l 3}

function :vec $expected_35() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_35_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_36(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 5
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_36(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 5
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_36_data = {l 0, l 5}

function :vec $expected_36() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_36_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_37(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 6
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_37(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 6
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_37_data = {l 0, l 6}

function :vec $expected_37() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_37_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_38(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 17
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_38(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_38_data = {l 0, l 17}

function :vec $expected_38() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_38_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_39(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 8
	call $push_long(l %delim_stack_ptr, l 38)
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 37)
	call $push_long(l %delim_stack_ptr, l 1)
	call $push_long(l %delim_stack_ptr, l 36)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_35(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_35()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_35()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_36(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_36()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_36()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_1()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @remove_delim_4
@missing_3
    %expected =:vec call $expected_1()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_37(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @remove_delim_4
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3

@remove_delim_4
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_4, @try_parse_4 
@check_eof_4
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_4, @check_4
@check_4
    %break_index =l sub %magic_num, 4
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_37()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_4, @remove_delim_5
@missing_4
    %expected =:vec call $expected_37()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_4

@try_parse_4
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_4, @remove_delim_5
@bump_err_4
    call $bump_err(l %state_ptr)
    jmp @try_parse_4

@remove_delim_5
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_5, @try_parse_5 
@check_eof_5
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_5, @check_5
@check_5
    %break_index =l sub %magic_num, 5
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_5, @check_last
@missing_5
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_5

@try_parse_5
    %res =l call $parse_38(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_5, @check_last
@bump_err_5
    call $bump_err(l %state_ptr)
    jmp @try_parse_5
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_38()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_39(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_39_data = {l 0, l 3}

function :vec $expected_39() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_39_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_40(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_39(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 11)
    %res =l call $parse_39(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_40(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_40_data = {l 1, l 11}

function :vec $expected_40() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_40_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_41(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_41(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_41_data = {l 0, l 3}

function :vec $expected_41() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_41_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_42(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_42(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_42_data = {l 0, l 10}

function :vec $expected_42() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_42_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_43(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 8
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_43(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 8
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_43_data = {l 0, l 8}

function :vec $expected_43() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_43_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_44(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 6
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 43)
	call $push_long(l %delim_stack_ptr, l 42)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_41(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_41()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_41()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_42(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_43(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_43()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @check_last
@missing_3
    %expected =:vec call $expected_43()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @check_last
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_44(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_44_data = {l 0, l 3}

function :vec $expected_44() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_44_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_45(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_44(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 12)
    %res =l call $parse_44(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_45(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_45_data = {l 1, l 12}

function :vec $expected_45() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_45_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_46(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_46(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_46_data = {l 0, l 3}

function :vec $expected_46() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_46_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_47(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_47(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_47_data = {l 0, l 10}

function :vec $expected_47() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_47_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 7
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_48(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_48_data = {l 0, l 7}

function :vec $expected_48() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_48_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_49(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 6
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 48)
	call $push_long(l %delim_stack_ptr, l 47)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_46(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_46()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_46()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_47(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_47()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_47()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @check_last
@missing_3
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @check_last
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_49(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_49_data = {l 0, l 3}

function :vec $expected_49() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_49_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_50(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_49(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 13)
    %res =l call $parse_49(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_50(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_50_data = {l 1, l 13}

function :vec $expected_50() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_50_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_51(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_51(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_51_data = {l 0, l 3}

function :vec $expected_51() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_51_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_52(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_52(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_52_data = {l 0, l 10}

function :vec $expected_52() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_52_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 9
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_53(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_53_data = {l 0, l 9}

function :vec $expected_53() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_53_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_54(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 53)
	call $push_long(l %delim_stack_ptr, l 52)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_51(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_51()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_51()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_52(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_52()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_52()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_53()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_54(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_54_data = {l 0, l 3}

function :vec $expected_54() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_54_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Named
function w $parse_55(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_54(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    call $enter_group(l %state_ptr, w 14)
    %res =l call $parse_54(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @remove_group, @exit
@exit
    call $exit_group(l %state_ptr)
    ret %res
@remove_group
    %stack_ptr =l add %state_ptr, 24
    call $pop(l %stack_ptr, l 32)
    ret %res
@eof
    ret 2
}
function w $peak_55(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_55_data = {l 1, l 14}

function :vec $expected_55() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_55_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_56(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_45(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_40(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_34(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_50(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_4, @ret
@check_4
    %res =l call $parse_55(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res

}
function w $peak_56(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_56_data = {l 1, l 12,l 1, l 11,l 1, l 10,l 1, l 13,l 1, l 14}

function :vec $expected_56() {
@start
    %ptr =l call $malloc(l 80)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_56_data, l 80)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 5, %len_ptr
    storel 5, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_57(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 43)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_42(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_42()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_43(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_43()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_43()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_57(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_57_data = {l 0, l 10}

function :vec $expected_57() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_57_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_58(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_57(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 12, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_58(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_58_data = {l 0, l 10}

function :vec $expected_58() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_58_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_59(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 48)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_47(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_47()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_47()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_59(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_59_data = {l 0, l 10}

function :vec $expected_59() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_59_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_60(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_59(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 13, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_60(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_60_data = {l 0, l 10}

function :vec $expected_60() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_60_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_61(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 7
	call $push_long(l %delim_stack_ptr, l 38)
	call $push_long(l %delim_stack_ptr, l 18)
	call $push_long(l %delim_stack_ptr, l 37)
	call $push_long(l %delim_stack_ptr, l 1)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_36(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_36()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_36()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_1(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_1()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @remove_delim_3
@missing_2
    %expected =:vec call $expected_1()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_37(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @remove_delim_3
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2

@remove_delim_3
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_3, @try_parse_3 
@check_eof_3
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_3, @check_3
@check_3
    %break_index =l sub %magic_num, 3
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_37()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_3, @remove_delim_4
@missing_3
    %expected =:vec call $expected_37()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_3

@try_parse_3
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_3, @remove_delim_4
@bump_err_3
    call $bump_err(l %state_ptr)
    jmp @try_parse_3

@remove_delim_4
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_4, @try_parse_4 
@check_eof_4
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_4, @check_4
@check_4
    %break_index =l sub %magic_num, 4
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_4, @check_last
@missing_4
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_4

@try_parse_4
    %res =l call $parse_38(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_4, @check_last
@bump_err_4
    call $bump_err(l %state_ptr)
    jmp @try_parse_4
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_38()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_61(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 5
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_61_data = {l 0, l 5}

function :vec $expected_61() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_61_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_62(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_61(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 11, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_62(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 5
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_62_data = {l 0, l 5}

function :vec $expected_62() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_62_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_63(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 53)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_52(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_52()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_52()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_53()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_63(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_63_data = {l 0, l 10}

function :vec $expected_63() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_63_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_64(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_63(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 14, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_64(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_64_data = {l 0, l 10}

function :vec $expected_64() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_64_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_65(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 5
	call $push_long(l %delim_stack_ptr, l 32)
	call $push_long(l %delim_stack_ptr, l 18)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_31(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @remove_delim_2
@missing_1
    %expected =:vec call $expected_31()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @remove_delim_2
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1

@remove_delim_2
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_2, @try_parse_2 
@check_eof_2
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_2, @check_2
@check_2
    %break_index =l sub %magic_num, 2
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_2, @check_last
@missing_2
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_2

@try_parse_2
    %res =l call $parse_32(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_2, @check_last
@bump_err_2
    call $bump_err(l %state_ptr)
    jmp @try_parse_2
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_32()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_65(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_65_data = {l 0, l 4}

function :vec $expected_65() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_65_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_66(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_65(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 10, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_66(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_66_data = {l 0, l 4}

function :vec $expected_66() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_66_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_67(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 3
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_67(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_67_data = {l 0, l 3}

function :vec $expected_67() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_67_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_68(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_58(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_60(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_62(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_64(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_4, @ret
@check_4
    %res =l call $parse_66(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    call $group_at(l %state_ptr, w 19, l %unmatched_checkpoint)
    ret %res

}
function w $peak_68(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 5
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_68_data = {l 0, l 10,l 0, l 10,l 0, l 5,l 0, l 10,l 0, l 4}

function :vec $expected_68() {
@start
    %ptr =l call $malloc(l 80)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_68_data, l 80)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 5, %len_ptr
    storel 5, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_69(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 3
	jmp @check_start_0

@check_start_0
    %res =l call $parse_53(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @check_last	@ret_err

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_53()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_69(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_69_data = {l 0, l 9}

function :vec $expected_69() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_69_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_70(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_69(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 14, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_70(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_70_data = {l 0, l 9}

function :vec $expected_70() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_70_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_71(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 18)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_43(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_43()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_43()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_71(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 8
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_71_data = {l 0, l 8}

function :vec $expected_71() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_71_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_72(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_71(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 12, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_72(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 8
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_72_data = {l 0, l 8}

function :vec $expected_72() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_72_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_73(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 18)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_48(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_48()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_18(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_18()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_73(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_73_data = {l 0, l 7}

function :vec $expected_73() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_73_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Rename
function w $parse_74(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %res =l call $parse_73(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @rename
@rename
    call $group_at(l %state_ptr, w 13, l %unmatched_checkpoint)
    ret 0
@ret_err
    ret %res
}
function w $peak_74(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_74_data = {l 0, l 7}

function :vec $expected_74() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_74_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_75(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 10
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_75(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_75_data = {l 0, l 10}

function :vec $expected_75() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_75_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_76(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_70(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_72(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_74(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    call $group_at(l %state_ptr, w 19, l %unmatched_checkpoint)
    ret %res

}
function w $peak_76(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 7
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 9
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 8
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_76_data = {l 0, l 9,l 0, l 8,l 0, l 7}

function :vec $expected_76() {
@start
    %ptr =l call $malloc(l 48)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_76_data, l 48)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 3, %len_ptr
    storel 3, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_77(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 76)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_75(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_75()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_75()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_76(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_76()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_77(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_77_data = {l 0, l 10}

function :vec $expected_77() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_77_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_78(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_77(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_58(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_60(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_62(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_4, @ret
@check_4
    %res =l call $parse_64(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_5, @ret
@check_5
    %res =l call $parse_66(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res

}
function w $peak_78(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 10
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 5
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 4
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_78_data = {l 0, l 10,l 0, l 10,l 0, l 10,l 0, l 5,l 0, l 10,l 0, l 4}

function :vec $expected_78() {
@start
    %ptr =l call $malloc(l 96)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_78_data, l 96)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 6, %len_ptr
    storel 6, %cap_ptr
    ret %res
}

# Parse Seq
function w $parse_79(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@add_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len_ptr =l add %state_ptr, 64
    %delim_stack_len =l loadl %delim_stack_len_ptr
    %magic_num =l add %delim_stack_len, 4
	call $push_long(l %delim_stack_ptr, l 78)
	jmp @check_start_0

@check_start_0
    %res =l call $parse_67(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @remove_delim_1
@remove_delim_1
    call $pop_delim(l %state_ptr)
    jnz %res, @check_eof_1, @try_parse_1 
@check_eof_1
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_1, @check_1
@check_1
    %break_index =l sub %magic_num, 1
    %is_me =l ceql %res, %break_index
    %expected =:vec call $expected_67()
    call $missing(l %state_ptr, l %expected)
    jnz %is_me, @try_parse_1, @check_last
@missing_1
    %expected =:vec call $expected_67()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_1

@try_parse_1
    %res =l call $parse_78(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_1, @check_last
@bump_err_1
    call $bump_err(l %state_ptr)
    jmp @try_parse_1
	@ret_err
	call $pop(l %delim_stack_ptr, l 8)

    ret %res
@check_last
    jnz %res, @check_eof_last, @ret_ok
@check_eof_last
    %is_eof =l ceql 2, %res
    jnz %is_eof, @missing_last, @check_break_last
@check_break_last
    %break_index =l sub %magic_num, 0
    %is_me =l ceql %res, %break_index
    jnz %is_me, @ret_ok, @missing_last
@missing_last
    %expected =:vec call $expected_78()
    call $missing(l %state_ptr, l %expected)
    jmp @ret_ok
@ret_ok
    ret 0
}
function w $peak_79(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_79_data = {l 0, l 3}

function :vec $expected_79() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_79_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_80(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_79(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_45(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_40(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_3, @ret
@check_3
    %res =l call $parse_34(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_4, @ret
@check_4
    %res =l call $parse_50(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_5, @ret
@check_5
    %res =l call $parse_55(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res

}
function w $peak_80(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_80_data = {l 0, l 3,l 1, l 12,l 1, l 11,l 1, l 10,l 1, l 13,l 1, l 14}

function :vec $expected_80() {
@start
    %ptr =l call $malloc(l 96)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_80_data, l 96)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 6, %len_ptr
    storel 6, %cap_ptr
    ret %res
}

# Parse Checkpoint
function w $parse_81(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %res =l call $peak_80(l %state_ptr, l 0, w 0)
    jnz %res, @check_skip, @parse
@check_skip
    %current_kind =l call $current_kind(l %state_ptr)
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @parse
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@parse
    %checkpoint =l call $checkpoint(l %state_ptr)
    %res =l call $parse_80(l %state_ptr, w %recover, l %checkpoint)
    ret %res
@eof
    ret 2
}
function w $peak_81(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_81_data = {l 0, l 3,l 1, l 12,l 1, l 11,l 1, l 10,l 1, l 13,l 1, l 14}

function :vec $expected_81() {
@start
    %ptr =l call $malloc(l 96)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_81_data, l 96)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 6, %len_ptr
    storel 6, %cap_ptr
    ret %res
}

# Build Choice
function w $parse_82(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@check_0
    %res =l call $parse_29(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_1, @ret
@check_1
    %res =l call $parse_24(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @check_2, @ret
@check_2
    %res =l call $parse_81(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @ret
@ret
    ret %res

@ret_err
    ret %res

}
function w $peak_82(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_82_data = {l 1, l 9,l 1, l 8,l 0, l 3,l 1, l 12,l 1, l 11,l 1, l 10,l 1, l 13,l 1, l 14}

function :vec $expected_82() {
@start
    %ptr =l call $malloc(l 128)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_82_data, l 128)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 8, %len_ptr
    storel 8, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_83(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 17
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_83(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 17
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_83_data = {l 0, l 17}

function :vec $expected_83() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_83_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Sep
function w $parse_84(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %item_index =l call $push_delim(l %state_ptr, l 82)
    %sep_index =l call $push_delim(l %state_ptr, l 83)
    %res =l call $parse_82(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %res, @ret_err, @try_parse_sep
@check_sep
    jnz %res, @check_sep_eof, @try_parse_item
@check_sep_eof
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @sep_check_item_delim
@sep_check_item_delim
    %is_item =w ceql %item_index, %res
    jnz %is_item, @missing_sep, @ret_ok
@missing_sep
    %expected =:vec call $expected_83()
    call $missing(l %state_ptr, l %expected)
    jmp @try_parse_item
@check_item
    jnz %res, @check_item_eof, @try_parse_sep
@check_item_eof
    %expected =:vec call $expected_82()
    call $missing(l %state_ptr, l %expected)
    %is_eof =w ceql %res, 2
    jnz %is_eof, @ret_ok, @item_check_sep_delim
@item_check_sep_delim
    %is_sep =w ceql %sep_index, %res
    jnz %is_sep, @try_parse_sep, @ret_ok

@try_parse_sep
    %res =l call $parse_83(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_sep, @check_sep
@bump_err_sep
    call $bump_err(l %state_ptr)
    jmp @try_parse_sep

@try_parse_item
    %res =l call $parse_82(l %state_ptr, w %recover, l %unmatched_checkpoint)
    %is_err =l ceql 1, %res
    jnz %is_err, @bump_err_item, @check_item
@bump_err_item
    call $bump_err(l %state_ptr)
    jmp @try_parse_item

@ret_ok
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret 0
@ret_err
    call $pop_delim(l %state_ptr)
    call $pop_delim(l %state_ptr)
    ret %res
}
function w $peak_84(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_84_data = {l 1, l 9,l 1, l 8,l 0, l 3,l 1, l 12,l 1, l 11,l 1, l 10,l 1, l 13,l 1, l 14}

function :vec $expected_84() {
@start
    %ptr =l call $malloc(l 128)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_84_data, l 128)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 8, %len_ptr
    storel 8, %cap_ptr
    ret %res
}


# Parse Just
function w $parse_85(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    jmp @check_eof
@check_eof
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @eof, @check_ok
@check_ok
    %current_kind =l call $current_kind(l %state_ptr)
    %res =l ceql %current_kind, 13
    jnz %res, @ret_ok, @check_skip
@check_skip
    %skip_ptr =l add %state_ptr, 80
    %is_skipped =l call $contains_long(l %skip_ptr, l %current_kind)
    jnz %is_skipped, @bump_skipped, @recover
@bump_skipped
    call $bump(l %state_ptr)
    jmp @check_eof
@recover
    jnz %recover, @check_delims, @ret_err
@check_delims
    %delim_stack_ptr =l add %state_ptr, 56
    %delim_stack_len =l add %state_ptr, 64
    %index =l loadl %delim_stack_len
    jnz %index, @loop, @ret_err
@loop
    %index =l sub %index, 1
    %parser_index_ptr =l call $get(l %delim_stack_ptr, l 8, l %index)
    %parser_index =l loadl %parser_index_ptr
    %rec_res =l call $peak_by_id(l %state_ptr, l 0, w 0, l %parser_index)
    jnz %rec_res, @iter, @ret_break
@iter
    jnz %index, @loop, @ret_err
@eof
    ret 2
@ret_break
    %break =l add %index, 3
    ret %break
@ret_ok
    call $bump(l %state_ptr)
    ret 0
@ret_err
    ret 1
}
function w $peak_85(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 13
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_85_data = {l 0, l 13}

function :vec $expected_85() {
@start
    %ptr =l call $malloc(l 16)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_85_data, l 16)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 1, %len_ptr
    storel 1, %cap_ptr
    ret %res
}

# Parse Skip
function w $parse_86(l %state_ptr, w %recover, l %unmatched_checkpoint) {
@start
    %skipped =l call $skip(l %state_ptr, l 13)
    %res =l call $parse_84(l %state_ptr, w %recover, l %unmatched_checkpoint)
    jnz %skipped, @unskip, @ret
@unskip
    call $unskip(l %state_ptr, l 13)
    ret %res
@ret
    ret %res
}
function w $peak_86(l %state_ptr, l %offset, w %recover) {
@start
    %current =l call $current_kind(l %state_ptr)
    jmp @check_0

@check_0
    %res =l ceql %current, 0
    jnz %res, @ret_ok, @check_1
@check_1
    %res =l ceql %current, 3
    jnz %res, @ret_ok, @check_2
@check_2
    %res =l ceql %current, 2
    jnz %res, @ret_ok, @ret_err
@ret_ok
    ret 0
@ret_err
    ret 1
}
data $expected_86_data = {l 1, l 9,l 1, l 8,l 0, l 3,l 1, l 12,l 1, l 11,l 1, l 10,l 1, l 13,l 1, l 14}

function :vec $expected_86() {
@start
    %ptr =l call $malloc(l 128)
    %res =l alloc8 24
    call $memcpy(l %ptr, l $expected_86_data, l 128)
    %len_ptr =l add %res, 8
    %cap_ptr =l add %res, 16
    
    storel %ptr, %res
    storel 8, %len_ptr
    storel 8, %cap_ptr
    ret %res
}

data $root_group_id = { w 18 }

export function w $parse(l %state_ptr) {
@start
    jmp @loop
@loop
    %res =l call $parse_86(l %state_ptr, w 1, l 0)
    jnz %res, @check_eof, @end
@check_eof
    %is_eof =l ceql %res, 2
    jnz %is_eof, @missing, @bump_err
@missing
    %expected =:vec call $expected_86()
    call $missing(l %state_ptr, l %expected)
    jmp @end
@bump_err
    call $bump_err(l %state_ptr)
    jmp @loop
@end
    %is_eof =w call $is_eof(l %state_ptr)
    jnz %is_eof, @ret, @expected_eof
@expected_eof
    call $bump_err(l %state_ptr)
    jmp @end
@ret
    ret 1
}

data $field_name_group_name = { b "field_name", b 0 }
data $field_name_group_name_len = { l 10 }

data $num_group_name = { b "num", b 0 }
data $num_group_name_len = { l 3 }

data $string_group_name = { b "string", b 0 }
data $string_group_name_len = { l 6 }

data $_expr_group_name = { b "_expr", b 0 }
data $_expr_group_name_len = { l 5 }

data $_atom_group_name = { b "_atom", b 0 }
data $_atom_group_name_len = { l 5 }

data $product_group_name = { b "product", b 0 }
data $product_group_name_len = { l 7 }

data $sum_group_name = { b "sum", b 0 }
data $sum_group_name_len = { l 3 }

data $table_name_group_name = { b "table_name", b 0 }
data $table_name_group_name_len = { l 10 }

data $select_stmt_group_name = { b "select_stmt", b 0 }
data $select_stmt_group_name_len = { l 11 }

data $delete_stmt_group_name = { b "delete_stmt", b 0 }
data $delete_stmt_group_name_len = { l 11 }

data $define_table_stmt_group_name = { b "define_table_stmt", b 0 }
data $define_table_stmt_group_name_len = { l 17 }

data $define_field_stmt_group_name = { b "define_field_stmt", b 0 }
data $define_field_stmt_group_name_len = { l 17 }

data $define_enum_stmt_group_name = { b "define_enum_stmt", b 0 }
data $define_enum_stmt_group_name_len = { l 16 }

data $define_struct_stmt_group_name = { b "define_struct_stmt", b 0 }
data $define_struct_stmt_group_name_len = { l 18 }

data $define_void_stmt_group_name = { b "define_void_stmt", b 0 }
data $define_void_stmt_group_name_len = { l 16 }

data $_define_stmt_group_name = { b "_define_stmt", b 0 }
data $_define_stmt_group_name_len = { l 12 }

data $_stmt_group_name = { b "_stmt", b 0 }
data $_stmt_group_name_len = { l 5 }

data $_root_group_name = { b "_root", b 0 }
data $_root_group_name_len = { l 5 }

data $root_group_name = { b "root", b 0 }
data $root_group_name_len = { l 4 }

data $unmatched_group_name = { b "unmatched", b 0 }
data $unmatched_group_name_len = { l 9 }

data $err_group_name = { b "group_error", b 0}


export function :str_slice $group_name(w %kind) {
@field_name
    %ptr =l copy $field_name_group_name
    %len =l copy 10
    %res =w ceqw %kind, 0
    jnz %res, @found, @num

@num
    %ptr =l copy $num_group_name
    %len =l copy 3
    %res =w ceqw %kind, 1
    jnz %res, @found, @string

@string
    %ptr =l copy $string_group_name
    %len =l copy 6
    %res =w ceqw %kind, 2
    jnz %res, @found, @_expr

@_expr
    %ptr =l copy $_expr_group_name
    %len =l copy 5
    %res =w ceqw %kind, 3
    jnz %res, @found, @_atom

@_atom
    %ptr =l copy $_atom_group_name
    %len =l copy 5
    %res =w ceqw %kind, 4
    jnz %res, @found, @product

@product
    %ptr =l copy $product_group_name
    %len =l copy 7
    %res =w ceqw %kind, 5
    jnz %res, @found, @sum

@sum
    %ptr =l copy $sum_group_name
    %len =l copy 3
    %res =w ceqw %kind, 6
    jnz %res, @found, @table_name

@table_name
    %ptr =l copy $table_name_group_name
    %len =l copy 10
    %res =w ceqw %kind, 7
    jnz %res, @found, @select_stmt

@select_stmt
    %ptr =l copy $select_stmt_group_name
    %len =l copy 11
    %res =w ceqw %kind, 8
    jnz %res, @found, @delete_stmt

@delete_stmt
    %ptr =l copy $delete_stmt_group_name
    %len =l copy 11
    %res =w ceqw %kind, 9
    jnz %res, @found, @define_table_stmt

@define_table_stmt
    %ptr =l copy $define_table_stmt_group_name
    %len =l copy 17
    %res =w ceqw %kind, 10
    jnz %res, @found, @define_field_stmt

@define_field_stmt
    %ptr =l copy $define_field_stmt_group_name
    %len =l copy 17
    %res =w ceqw %kind, 11
    jnz %res, @found, @define_enum_stmt

@define_enum_stmt
    %ptr =l copy $define_enum_stmt_group_name
    %len =l copy 16
    %res =w ceqw %kind, 12
    jnz %res, @found, @define_struct_stmt

@define_struct_stmt
    %ptr =l copy $define_struct_stmt_group_name
    %len =l copy 18
    %res =w ceqw %kind, 13
    jnz %res, @found, @define_void_stmt

@define_void_stmt
    %ptr =l copy $define_void_stmt_group_name
    %len =l copy 16
    %res =w ceqw %kind, 14
    jnz %res, @found, @_define_stmt

@_define_stmt
    %ptr =l copy $_define_stmt_group_name
    %len =l copy 12
    %res =w ceqw %kind, 15
    jnz %res, @found, @_stmt

@_stmt
    %ptr =l copy $_stmt_group_name
    %len =l copy 5
    %res =w ceqw %kind, 16
    jnz %res, @found, @_root

@_root
    %ptr =l copy $_root_group_name
    %len =l copy 5
    %res =w ceqw %kind, 17
    jnz %res, @found, @root

@root
    %ptr =l copy $root_group_name
    %len =l copy 4
    %res =w ceqw %kind, 18
    jnz %res, @found, @unmatched

@unmatched
    %ptr =l copy $unmatched_group_name
    %len =l copy 9
    %res =w ceqw %kind, 19
    jnz %res, @found, @err

@err
    %ptr =l copy $err_group_name
    %len =l copy 5
    jmp @found
@found
    %slice =l alloc8 16
    %len_ptr =l add %slice, 8
    
    storel %ptr, %slice
    storel %len, %len_ptr
    ret %slice
}